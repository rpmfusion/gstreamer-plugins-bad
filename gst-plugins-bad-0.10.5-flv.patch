diff -up /dev/null gst-plugins-bad-0.10.5/gst/flv/gstflvdemux.c
--- /dev/null	2008-02-05 09:36:22.221546318 +0100
+++ gst-plugins-bad-0.10.5/gst/flv/gstflvdemux.c	2008-02-05 10:33:21.000000000 +0100
@@ -0,0 +1,1200 @@
+/* GStreamer
+ * Copyright (C) <2007> Julien Moutte <julien@moutte.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstflvdemux.h"
+#include "gstflvparse.h"
+
+#include <string.h>
+
+static GstStaticPadTemplate flv_sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-flv")
+    );
+
+static GstStaticPadTemplate audio_src_template =
+GST_STATIC_PAD_TEMPLATE ("audio",
+    GST_PAD_SRC,
+    GST_PAD_SOMETIMES,
+    GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate video_src_template =
+GST_STATIC_PAD_TEMPLATE ("video",
+    GST_PAD_SRC,
+    GST_PAD_SOMETIMES,
+    GST_STATIC_CAPS_ANY);
+
+static GstElementDetails flv_demux_details = {
+  "FLV Demuxer",
+  "Codec/Demuxer",
+  "Demux FLV feeds into digital streams",
+  "Julien Moutte <julien@moutte.net>"
+};
+
+GST_DEBUG_CATEGORY (flvdemux_debug);
+#define GST_CAT_DEFAULT flvdemux_debug
+
+GST_BOILERPLATE (GstFLVDemux, gst_flv_demux, GstElement, GST_TYPE_ELEMENT);
+
+#define FLV_HEADER_SIZE 13
+#define FLV_TAG_TYPE_SIZE 4
+
+static void
+gst_flv_demux_flush (GstFLVDemux * demux, gboolean discont)
+{
+  GST_DEBUG_OBJECT (demux, "flushing queued data in the FLV demuxer");
+
+  gst_adapter_clear (demux->adapter);
+
+  demux->audio_need_discont = TRUE;
+  demux->video_need_discont = TRUE;
+
+  demux->flushing = FALSE;
+
+  /* Only in push mode */
+  if (!demux->random_access) {
+    /* After a flush we expect a tag_type */
+    demux->state = FLV_STATE_TAG_TYPE;
+    /* We reset the offset and will get one from first push */
+    demux->offset = 0;
+  }
+}
+
+static void
+gst_flv_demux_cleanup (GstFLVDemux * demux)
+{
+  GST_DEBUG_OBJECT (demux, "cleaning up FLV demuxer");
+
+  demux->state = FLV_STATE_HEADER;
+
+  demux->flushing = FALSE;
+  demux->need_header = TRUE;
+  demux->audio_need_segment = TRUE;
+  demux->video_need_segment = TRUE;
+  demux->audio_need_discont = TRUE;
+  demux->video_need_discont = TRUE;
+
+  /* By default we consider them as linked */
+  demux->audio_linked = TRUE;
+  demux->video_linked = TRUE;
+
+  demux->has_audio = FALSE;
+  demux->has_video = FALSE;
+  demux->push_tags = FALSE;
+  demux->got_par = FALSE;
+
+  demux->w = demux->h = 0;
+  demux->par_x = demux->par_y = 1;
+  demux->video_offset = 0;
+  demux->audio_offset = 0;
+  demux->offset = demux->cur_tag_offset = 0;
+  demux->tag_size = demux->tag_data_size = 0;
+  demux->duration = GST_CLOCK_TIME_NONE;
+
+  if (demux->new_seg_event) {
+    gst_event_unref (demux->new_seg_event);
+    demux->new_seg_event = NULL;
+  }
+
+  gst_adapter_clear (demux->adapter);
+
+  if (demux->audio_pad) {
+    gst_element_remove_pad (GST_ELEMENT (demux), demux->audio_pad);
+    gst_object_unref (demux->audio_pad);
+    demux->audio_pad = NULL;
+  }
+
+  if (demux->video_pad) {
+    gst_element_remove_pad (GST_ELEMENT (demux), demux->video_pad);
+    gst_object_unref (demux->video_pad);
+    demux->video_pad = NULL;
+  }
+
+  if (demux->times) {
+    g_array_free (demux->times, TRUE);
+    demux->times = NULL;
+  }
+
+  if (demux->filepositions) {
+    g_array_free (demux->filepositions, TRUE);
+    demux->filepositions = NULL;
+  }
+}
+
+static void
+gst_flv_demux_adapter_flush (GstFLVDemux * demux, guint64 bytes)
+{
+  demux->offset += bytes;
+
+  gst_adapter_flush (demux->adapter, bytes);
+}
+
+static GstFlowReturn
+gst_flv_demux_chain (GstPad * pad, GstBuffer * buffer)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+  GstFLVDemux *demux = NULL;
+
+  demux = GST_FLV_DEMUX (gst_pad_get_parent (pad));
+
+  GST_LOG_OBJECT (demux, "received buffer of %d bytes at offset %"
+      G_GUINT64_FORMAT, GST_BUFFER_SIZE (buffer), GST_BUFFER_OFFSET (buffer));
+
+  if (G_UNLIKELY (GST_BUFFER_OFFSET (buffer) == 0)) {
+    GST_DEBUG_OBJECT (demux, "beginning of file, expect header");
+    demux->state = FLV_STATE_HEADER;
+    demux->offset = 0;
+  }
+
+  if (G_UNLIKELY (demux->offset == 0)) {
+    GST_DEBUG_OBJECT (demux, "offset was zero, synchronizing with buffer's");
+    demux->offset = GST_BUFFER_OFFSET (buffer);
+  }
+
+  gst_adapter_push (demux->adapter, buffer);
+
+parse:
+  if (G_UNLIKELY (demux->flushing)) {
+    GST_DEBUG_OBJECT (demux, "we are now flushing, exiting parser loop");
+    ret = GST_FLOW_WRONG_STATE;
+    goto beach;
+  }
+  switch (demux->state) {
+    case FLV_STATE_HEADER:
+    {
+      if (gst_adapter_available (demux->adapter) >= FLV_HEADER_SIZE) {
+        const guint8 *data;
+
+        data = gst_adapter_peek (demux->adapter, FLV_HEADER_SIZE);
+
+        ret = gst_flv_parse_header (demux, data, FLV_HEADER_SIZE);
+
+        gst_flv_demux_adapter_flush (demux, FLV_HEADER_SIZE);
+
+        demux->state = FLV_STATE_TAG_TYPE;
+        goto parse;
+      } else {
+        goto beach;
+      }
+    }
+    case FLV_STATE_TAG_TYPE:
+    {
+      if (gst_adapter_available (demux->adapter) >= FLV_TAG_TYPE_SIZE) {
+        const guint8 *data;
+
+        /* Remember the tag offset in bytes */
+        demux->cur_tag_offset = demux->offset;
+
+        data = gst_adapter_peek (demux->adapter, FLV_TAG_TYPE_SIZE);
+
+        ret = gst_flv_parse_tag_type (demux, data, FLV_TAG_TYPE_SIZE);
+
+        gst_flv_demux_adapter_flush (demux, FLV_TAG_TYPE_SIZE);
+
+        goto parse;
+      } else {
+        goto beach;
+      }
+    }
+    case FLV_STATE_TAG_VIDEO:
+    {
+      if (gst_adapter_available (demux->adapter) >= demux->tag_size) {
+        const guint8 *data;
+
+        data = gst_adapter_peek (demux->adapter, demux->tag_size);
+
+        ret = gst_flv_parse_tag_video (demux, data, demux->tag_size);
+
+        gst_flv_demux_adapter_flush (demux, demux->tag_size);
+
+        demux->state = FLV_STATE_TAG_TYPE;
+        goto parse;
+      } else {
+        goto beach;
+      }
+    }
+    case FLV_STATE_TAG_AUDIO:
+    {
+      if (gst_adapter_available (demux->adapter) >= demux->tag_size) {
+        const guint8 *data;
+
+        data = gst_adapter_peek (demux->adapter, demux->tag_size);
+
+        ret = gst_flv_parse_tag_audio (demux, data, demux->tag_size);
+
+        gst_flv_demux_adapter_flush (demux, demux->tag_size);
+
+        demux->state = FLV_STATE_TAG_TYPE;
+        goto parse;
+      } else {
+        goto beach;
+      }
+    }
+    case FLV_STATE_TAG_SCRIPT:
+    {
+      if (gst_adapter_available (demux->adapter) >= demux->tag_size) {
+        const guint8 *data;
+
+        data = gst_adapter_peek (demux->adapter, demux->tag_size);
+
+        ret = gst_flv_parse_tag_script (demux, data, demux->tag_size);
+
+        gst_flv_demux_adapter_flush (demux, demux->tag_size);
+
+        demux->state = FLV_STATE_TAG_TYPE;
+        goto parse;
+      } else {
+        goto beach;
+      }
+    }
+    default:
+      GST_DEBUG_OBJECT (demux, "unexpected demuxer state");
+  }
+
+beach:
+  if (G_UNLIKELY (ret == GST_FLOW_NOT_LINKED)) {
+    /* If either audio or video is linked we return GST_FLOW_OK */
+    if (demux->audio_linked || demux->video_linked) {
+      ret = GST_FLOW_OK;
+    }
+  }
+
+  gst_object_unref (demux);
+
+  return ret;
+}
+
+static GstFlowReturn
+gst_flv_demux_pull_tag (GstPad * pad, GstFLVDemux * demux)
+{
+  GstBuffer *buffer = NULL;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  /* Store tag offset */
+  demux->cur_tag_offset = demux->offset;
+
+  /* Get the first 4 bytes to identify tag type and size */
+  ret = gst_pad_pull_range (pad, demux->offset, FLV_TAG_TYPE_SIZE, &buffer);
+  if (G_UNLIKELY (ret != GST_FLOW_OK)) {
+    GST_WARNING_OBJECT (demux, "failed when pulling %d bytes",
+        FLV_TAG_TYPE_SIZE);
+    goto beach;
+  }
+
+  if (G_UNLIKELY (buffer && GST_BUFFER_SIZE (buffer) != FLV_TAG_TYPE_SIZE)) {
+    GST_WARNING_OBJECT (demux, "partial pull got %d when expecting %d",
+        GST_BUFFER_SIZE (buffer), FLV_TAG_TYPE_SIZE);
+    gst_buffer_unref (buffer);
+    ret = GST_FLOW_UNEXPECTED;
+    goto beach;
+  }
+
+  /* Identify tag type */
+  ret = gst_flv_parse_tag_type (demux, GST_BUFFER_DATA (buffer),
+      GST_BUFFER_SIZE (buffer));
+
+  gst_buffer_unref (buffer);
+
+  /* Jump over tag type + size */
+  demux->offset += FLV_TAG_TYPE_SIZE;
+
+  /* Pull the whole tag */
+  ret = gst_pad_pull_range (pad, demux->offset, demux->tag_size, &buffer);
+  if (G_UNLIKELY (ret != GST_FLOW_OK)) {
+    GST_WARNING_OBJECT (demux,
+        "failed when pulling %" G_GUINT64_FORMAT " bytes", demux->tag_size);
+    goto beach;
+  }
+
+  if (G_UNLIKELY (buffer && GST_BUFFER_SIZE (buffer) != demux->tag_size)) {
+    GST_WARNING_OBJECT (demux,
+        "partial pull got %d when expecting %" G_GUINT64_FORMAT,
+        GST_BUFFER_SIZE (buffer), demux->tag_size);
+    gst_buffer_unref (buffer);
+    ret = GST_FLOW_UNEXPECTED;
+    goto beach;
+  }
+
+  switch (demux->state) {
+    case FLV_STATE_TAG_VIDEO:
+      ret = gst_flv_parse_tag_video (demux, GST_BUFFER_DATA (buffer),
+          GST_BUFFER_SIZE (buffer));
+      break;
+    case FLV_STATE_TAG_AUDIO:
+      ret = gst_flv_parse_tag_audio (demux, GST_BUFFER_DATA (buffer),
+          GST_BUFFER_SIZE (buffer));
+      break;
+    case FLV_STATE_TAG_SCRIPT:
+      ret = gst_flv_parse_tag_script (demux, GST_BUFFER_DATA (buffer),
+          GST_BUFFER_SIZE (buffer));
+      break;
+    default:
+      GST_WARNING_OBJECT (demux, "unexpected state %d", demux->state);
+  }
+
+  gst_buffer_unref (buffer);
+
+  /* Jump over that part we've just parsed */
+  demux->offset += demux->tag_size;
+
+  /* Make sure we reinitialize the tag size */
+  demux->tag_size = 0;
+
+  /* Ready for the next tag */
+  demux->state = FLV_STATE_TAG_TYPE;
+
+  if (G_UNLIKELY (ret == GST_FLOW_NOT_LINKED)) {
+    /* If either audio or video is linked we return GST_FLOW_OK */
+    if (demux->audio_linked || demux->video_linked) {
+      ret = GST_FLOW_OK;
+    } else {
+      GST_WARNING_OBJECT (demux, "parsing this tag returned not-linked and "
+          "neither video nor audio are linked");
+    }
+  }
+
+beach:
+  return ret;
+}
+
+static GstFlowReturn
+gst_flv_demux_pull_header (GstPad * pad, GstFLVDemux * demux)
+{
+  GstBuffer *buffer = NULL;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  /* Get the first 9 bytes */
+  ret = gst_pad_pull_range (pad, demux->offset, FLV_HEADER_SIZE, &buffer);
+  if (G_UNLIKELY (ret != GST_FLOW_OK)) {
+    GST_WARNING_OBJECT (demux, "failed when pulling %d bytes", FLV_HEADER_SIZE);
+    goto beach;
+  }
+
+  if (G_UNLIKELY (buffer && GST_BUFFER_SIZE (buffer) != FLV_HEADER_SIZE)) {
+    GST_WARNING_OBJECT (demux, "partial pull got %d when expecting %d",
+        GST_BUFFER_SIZE (buffer), FLV_HEADER_SIZE);
+    gst_buffer_unref (buffer);
+    ret = GST_FLOW_UNEXPECTED;
+    goto beach;
+  }
+
+  ret = gst_flv_parse_header (demux, GST_BUFFER_DATA (buffer),
+      GST_BUFFER_SIZE (buffer));
+
+  /* Jump over the header now */
+  demux->offset += FLV_HEADER_SIZE;
+  demux->state = FLV_STATE_TAG_TYPE;
+
+beach:
+  return ret;
+}
+
+static GstFlowReturn
+gst_flv_demux_seek_to_prev_keyframe (GstFLVDemux * demux)
+{
+  return GST_FLOW_OK;
+}
+
+static void
+gst_flv_demux_loop (GstPad * pad)
+{
+  GstFLVDemux *demux = NULL;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  demux = GST_FLV_DEMUX (gst_pad_get_parent (pad));
+
+  if (demux->segment->rate >= 0) {
+    /* pull in data */
+    switch (demux->state) {
+      case FLV_STATE_TAG_TYPE:
+        ret = gst_flv_demux_pull_tag (pad, demux);
+        break;
+      case FLV_STATE_DONE:
+        ret = GST_FLOW_UNEXPECTED;
+        break;
+      default:
+        ret = gst_flv_demux_pull_header (pad, demux);
+    }
+
+    /* pause if something went wrong */
+    if (G_UNLIKELY (ret != GST_FLOW_OK))
+      goto pause;
+
+    /* check EOS condition */
+    if ((demux->segment->flags & GST_SEEK_FLAG_SEGMENT) &&
+        (demux->segment->stop != -1) &&
+        (demux->segment->last_stop >= demux->segment->stop)) {
+      ret = GST_FLOW_UNEXPECTED;
+      goto pause;
+    }
+  } else {                      /* Reverse playback */
+    /* pull in data */
+    switch (demux->state) {
+      case FLV_STATE_TAG_TYPE:
+        ret = gst_flv_demux_pull_tag (pad, demux);
+        /* When packet parsing returns UNEXPECTED that means we ve reached the
+           point where we want to go to the previous keyframe. This is either
+           the last FLV tag or the keyframe we used last time */
+        if (ret == GST_FLOW_UNEXPECTED) {
+          ret = gst_flv_demux_seek_to_prev_keyframe (demux);
+          demux->state = FLV_STATE_TAG_TYPE;
+        }
+        break;
+      default:
+        ret = gst_flv_demux_pull_header (pad, demux);
+    }
+
+    /* pause if something went wrong */
+    if (G_UNLIKELY (ret != GST_FLOW_OK))
+      goto pause;
+
+    /* check EOS condition */
+    if (demux->segment->last_stop <= demux->segment->start) {
+      ret = GST_FLOW_UNEXPECTED;
+      goto pause;
+    }
+  }
+
+  gst_object_unref (demux);
+
+  return;
+
+pause:
+  {
+    const gchar *reason = gst_flow_get_name (ret);
+
+    GST_LOG_OBJECT (demux, "pausing task, reason %s", reason);
+    gst_pad_pause_task (pad);
+
+    if (GST_FLOW_IS_FATAL (ret) || ret == GST_FLOW_NOT_LINKED) {
+      if (ret == GST_FLOW_UNEXPECTED) {
+        /* perform EOS logic */
+        gst_element_no_more_pads (GST_ELEMENT_CAST (demux));
+        if (demux->segment->flags & GST_SEEK_FLAG_SEGMENT) {
+          gint64 stop;
+
+          /* for segment playback we need to post when (in stream time)
+           * we stopped, this is either stop (when set) or the duration. */
+          if ((stop = demux->segment->stop) == -1)
+            stop = demux->segment->duration;
+
+          if (demux->segment->rate >= 0) {
+            GST_LOG_OBJECT (demux, "Sending segment done, at end of segment");
+            gst_element_post_message (GST_ELEMENT_CAST (demux),
+                gst_message_new_segment_done (GST_OBJECT_CAST (demux),
+                    GST_FORMAT_TIME, stop));
+          } else {              /* Reverse playback */
+            GST_LOG_OBJECT (demux, "Sending segment done, at beginning of "
+                "segment");
+            gst_element_post_message (GST_ELEMENT_CAST (demux),
+                gst_message_new_segment_done (GST_OBJECT_CAST (demux),
+                    GST_FORMAT_TIME, demux->segment->start));
+          }
+        } else {
+          /* normal playback, send EOS to all linked pads */
+          gst_element_no_more_pads (GST_ELEMENT (demux));
+          GST_LOG_OBJECT (demux, "Sending EOS, at end of stream");
+          if (!gst_pad_event_default (demux->sinkpad, gst_event_new_eos ())) {
+            GST_WARNING_OBJECT (demux, "failed pushing EOS on streams");
+            GST_ELEMENT_ERROR (demux, STREAM, FAILED,
+                ("Internal data stream error."),
+                ("Can't push EOS downstream (empty/invalid file "
+                    "with no streams/tags ?)"));
+          }
+        }
+      } else {
+        GST_ELEMENT_ERROR (demux, STREAM, FAILED,
+            ("Internal data stream error."),
+            ("stream stopped, reason %s", reason));
+        gst_pad_event_default (demux->sinkpad, gst_event_new_eos ());
+      }
+    }
+    gst_object_unref (demux);
+    return;
+  }
+}
+
+static guint64
+gst_flv_demux_find_offset (GstFLVDemux * demux, GstSegment * segment)
+{
+  gint64 bytes = 0;
+  gint64 time = 0;
+  GstIndexEntry *entry;
+
+  g_return_val_if_fail (segment != NULL, 0);
+
+  time = segment->start;
+
+  if (demux->index) {
+    /* Let's check if we have an index entry for that seek time */
+    entry = gst_index_get_assoc_entry (demux->index, demux->index_id,
+        GST_INDEX_LOOKUP_BEFORE, GST_ASSOCIATION_FLAG_KEY_UNIT, GST_FORMAT_TIME,
+        time);
+
+    if (entry) {
+      gst_index_entry_assoc_map (entry, GST_FORMAT_BYTES, &bytes);
+      gst_index_entry_assoc_map (entry, GST_FORMAT_TIME, &time);
+
+      GST_DEBUG_OBJECT (demux, "found index entry for %" GST_TIME_FORMAT
+          " at %" GST_TIME_FORMAT ", seeking to %" G_GINT64_FORMAT,
+          GST_TIME_ARGS (segment->start), GST_TIME_ARGS (time), bytes);
+
+      /* Key frame seeking */
+      if (segment->flags & GST_SEEK_FLAG_KEY_UNIT) {
+        /* Adjust the segment so that the keyframe fits in */
+        if (time < segment->start) {
+          segment->start = segment->time = time;
+        }
+        segment->last_stop = time;
+      }
+    } else {
+      GST_DEBUG_OBJECT (demux, "no index entry found for %" GST_TIME_FORMAT,
+          GST_TIME_ARGS (segment->start));
+    }
+  }
+
+  return bytes;
+}
+
+static gboolean
+gst_flv_demux_handle_seek_push (GstFLVDemux * demux, GstEvent * event)
+{
+  GstFormat format;
+  GstSeekFlags flags;
+  GstSeekType start_type, stop_type;
+  gint64 start, stop;
+  gdouble rate;
+  gboolean update, flush, keyframe, ret;
+  GstSegment seeksegment;
+
+  gst_event_parse_seek (event, &rate, &format, &flags,
+      &start_type, &start, &stop_type, &stop);
+
+  if (format != GST_FORMAT_TIME)
+    goto wrong_format;
+
+  flush = flags & GST_SEEK_FLAG_FLUSH;
+  keyframe = flags & GST_SEEK_FLAG_KEY_UNIT;
+
+  /* Work on a copy until we are sure the seek succeeded. */
+  memcpy (&seeksegment, demux->segment, sizeof (GstSegment));
+
+  GST_DEBUG_OBJECT (demux, "segment before configure %" GST_SEGMENT_FORMAT,
+      demux->segment);
+
+  /* Apply the seek to our segment */
+  gst_segment_set_seek (&seeksegment, rate, format, flags,
+      start_type, start, stop_type, stop, &update);
+
+  GST_DEBUG_OBJECT (demux, "segment configured %" GST_SEGMENT_FORMAT,
+      &seeksegment);
+
+  if (flush || seeksegment.last_stop != demux->segment->last_stop) {
+    /* Do the actual seeking */
+    guint64 offset = gst_flv_demux_find_offset (demux, &seeksegment);
+
+    GST_DEBUG_OBJECT (demux, "generating an upstream seek at position %"
+        G_GUINT64_FORMAT, offset);
+    ret = gst_pad_push_event (demux->sinkpad,
+        gst_event_new_seek (seeksegment.rate, GST_FORMAT_BYTES,
+            GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE, GST_SEEK_TYPE_SET,
+            offset, GST_SEEK_TYPE_NONE, 0));
+    if (G_UNLIKELY (!ret)) {
+      GST_WARNING_OBJECT (demux, "upstream seek failed");
+    }
+  } else {
+    ret = TRUE;
+  }
+
+  if (ret) {
+    /* Ok seek succeeded, take the newly configured segment */
+    memcpy (demux->segment, &seeksegment, sizeof (GstSegment));
+
+    /* Notify about the start of a new segment */
+    if (demux->segment->flags & GST_SEEK_FLAG_SEGMENT) {
+      gst_element_post_message (GST_ELEMENT (demux),
+          gst_message_new_segment_start (GST_OBJECT (demux),
+              demux->segment->format, demux->segment->last_stop));
+    }
+
+    /* Tell all the stream a new segment is needed */
+    {
+      demux->audio_need_segment = TRUE;
+      demux->video_need_segment = TRUE;
+      /* Clean any potential newsegment event kept for the streams. The first
+       * stream needing a new segment will create a new one. */
+      if (G_UNLIKELY (demux->new_seg_event)) {
+        gst_event_unref (demux->new_seg_event);
+        demux->new_seg_event = NULL;
+      }
+    }
+  }
+
+  return ret;
+
+/* ERRORS */
+wrong_format:
+  {
+    GST_WARNING_OBJECT (demux, "we only support seeking in TIME format");
+    return FALSE;
+  }
+}
+
+static gboolean
+gst_flv_demux_handle_seek_pull (GstFLVDemux * demux, GstEvent * event)
+{
+  GstFormat format;
+  GstSeekFlags flags;
+  GstSeekType start_type, stop_type;
+  gint64 start, stop;
+  gdouble rate;
+  gboolean update, flush, keyframe, ret;
+  GstSegment seeksegment;
+
+  gst_event_parse_seek (event, &rate, &format, &flags,
+      &start_type, &start, &stop_type, &stop);
+
+  if (format != GST_FORMAT_TIME)
+    goto wrong_format;
+
+  flush = flags & GST_SEEK_FLAG_FLUSH;
+  keyframe = flags & GST_SEEK_FLAG_KEY_UNIT;
+
+  if (flush) {
+    /* Flush start up and downstream to make sure data flow and loops are
+       idle */
+    gst_pad_event_default (demux->sinkpad, gst_event_new_flush_start ());
+    gst_pad_push_event (demux->sinkpad, gst_event_new_flush_start ());
+  } else {
+    /* Pause the pulling task */
+    gst_pad_pause_task (demux->sinkpad);
+  }
+
+  /* Take the stream lock */
+  GST_PAD_STREAM_LOCK (demux->sinkpad);
+
+  if (flush) {
+    /* Stop flushing upstream we need to pull */
+    gst_pad_push_event (demux->sinkpad, gst_event_new_flush_stop ());
+  }
+
+  /* Work on a copy until we are sure the seek succeeded. */
+  memcpy (&seeksegment, demux->segment, sizeof (GstSegment));
+
+  GST_DEBUG_OBJECT (demux, "segment before configure %" GST_SEGMENT_FORMAT,
+      demux->segment);
+
+  /* Apply the seek to our segment */
+  gst_segment_set_seek (&seeksegment, rate, format, flags,
+      start_type, start, stop_type, stop, &update);
+
+  GST_DEBUG_OBJECT (demux, "segment configured %" GST_SEGMENT_FORMAT,
+      &seeksegment);
+
+  if (flush || seeksegment.last_stop != demux->segment->last_stop) {
+    /* Do the actual seeking */
+    demux->offset = gst_flv_demux_find_offset (demux, &seeksegment);
+
+    /* If we seeked at the beginning of the file parse the header again */
+    if (G_UNLIKELY (!demux->offset)) {
+      demux->state = FLV_STATE_HEADER;
+    } else {                    /* or parse a tag */
+      demux->state = FLV_STATE_TAG_TYPE;
+    }
+    ret = TRUE;
+  } else {
+    ret = TRUE;
+  }
+
+  if (flush) {
+    /* Stop flushing, the sinks are at time 0 now */
+    gst_pad_event_default (demux->sinkpad, gst_event_new_flush_stop ());
+  } else {
+    GST_DEBUG_OBJECT (demux, "closing running segment %" GST_SEGMENT_FORMAT,
+        demux->segment);
+
+    /* Close the current segment for a linear playback, FIXME, queue for
+     * streaming thread. */
+    if (demux->segment->rate >= 0) {
+      /* for forward playback, we played from start to last_stop */
+      gst_pad_event_default (demux->sinkpad, gst_event_new_new_segment (TRUE,
+              demux->segment->rate, demux->segment->format,
+              demux->segment->start, demux->segment->last_stop,
+              demux->segment->time));
+    } else {
+      gint64 stop;
+
+      if ((stop = demux->segment->stop) == -1)
+        stop = demux->segment->duration;
+
+      /* for reverse playback, we played from stop to last_stop. */
+      gst_pad_event_default (demux->sinkpad, gst_event_new_new_segment (TRUE,
+              demux->segment->rate, demux->segment->format,
+              demux->segment->last_stop, stop, demux->segment->last_stop));
+    }
+  }
+
+  if (ret) {
+    /* Ok seek succeeded, take the newly configured segment */
+    memcpy (demux->segment, &seeksegment, sizeof (GstSegment));
+
+    /* Notify about the start of a new segment */
+    if (demux->segment->flags & GST_SEEK_FLAG_SEGMENT) {
+      gst_element_post_message (GST_ELEMENT (demux),
+          gst_message_new_segment_start (GST_OBJECT (demux),
+              demux->segment->format, demux->segment->last_stop));
+    }
+
+    /* Tell all the stream a new segment is needed */
+    {
+      demux->audio_need_segment = TRUE;
+      demux->video_need_segment = TRUE;
+      /* Clean any potential newsegment event kept for the streams. The first
+       * stream needing a new segment will create a new one. */
+      if (G_UNLIKELY (demux->new_seg_event)) {
+        gst_event_unref (demux->new_seg_event);
+        demux->new_seg_event = NULL;
+      }
+    }
+  }
+
+  gst_pad_start_task (demux->sinkpad,
+      (GstTaskFunction) gst_flv_demux_loop, demux->sinkpad);
+
+  GST_PAD_STREAM_UNLOCK (demux->sinkpad);
+
+  return ret;
+
+  /* ERRORS */
+wrong_format:
+  {
+    GST_WARNING_OBJECT (demux, "we only support seeking in TIME format");
+    return FALSE;
+  }
+}
+
+/* If we can pull that's prefered */
+static gboolean
+gst_flv_demux_sink_activate (GstPad * sinkpad)
+{
+  if (gst_pad_check_pull_range (sinkpad)) {
+    return gst_pad_activate_pull (sinkpad, TRUE);
+  } else {
+    return gst_pad_activate_push (sinkpad, TRUE);
+  }
+}
+
+/* This function gets called when we activate ourselves in push mode.
+ * We cannot seek (ourselves) in the stream */
+static gboolean
+gst_flv_demux_sink_activate_push (GstPad * sinkpad, gboolean active)
+{
+  GstFLVDemux *demux;
+
+  demux = GST_FLV_DEMUX (gst_pad_get_parent (sinkpad));
+
+  demux->random_access = FALSE;
+
+  gst_object_unref (demux);
+
+  return TRUE;
+}
+
+/* this function gets called when we activate ourselves in pull mode.
+ * We can perform  random access to the resource and we start a task
+ * to start reading */
+static gboolean
+gst_flv_demux_sink_activate_pull (GstPad * sinkpad, gboolean active)
+{
+  GstFLVDemux *demux;
+
+  demux = GST_FLV_DEMUX (gst_pad_get_parent (sinkpad));
+
+  if (active) {
+    demux->random_access = TRUE;
+    gst_object_unref (demux);
+    return gst_pad_start_task (sinkpad, (GstTaskFunction) gst_flv_demux_loop,
+        sinkpad);
+  } else {
+    demux->random_access = FALSE;
+    gst_object_unref (demux);
+    return gst_pad_stop_task (sinkpad);
+  }
+}
+
+static gboolean
+gst_flv_demux_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstFLVDemux *demux;
+  gboolean ret = FALSE;
+
+  demux = GST_FLV_DEMUX (gst_pad_get_parent (pad));
+
+  GST_DEBUG_OBJECT (demux, "handling event %s", GST_EVENT_TYPE_NAME (event));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_START:
+      GST_DEBUG_OBJECT (demux, "trying to force chain function to exit");
+      demux->flushing = TRUE;
+      ret = gst_pad_event_default (demux->sinkpad, event);
+      break;
+    case GST_EVENT_FLUSH_STOP:
+      GST_DEBUG_OBJECT (demux, "flushing FLV demuxer");
+      gst_flv_demux_flush (demux, TRUE);
+      ret = gst_pad_event_default (demux->sinkpad, event);
+      break;
+    case GST_EVENT_EOS:
+      GST_DEBUG_OBJECT (demux, "received EOS");
+      if (demux->index) {
+        GST_DEBUG_OBJECT (demux, "committing index");
+        gst_index_commit (demux->index, demux->index_id);
+      }
+      gst_element_no_more_pads (GST_ELEMENT (demux));
+      if (!gst_pad_event_default (demux->sinkpad, event)) {
+        GST_WARNING_OBJECT (demux, "failed pushing EOS on streams");
+        GST_ELEMENT_ERROR (demux, STREAM, FAILED,
+            ("Internal data stream error."),
+            ("Can't push EOS downstream (empty/invalid file "
+                "with no streams/tags ?)"));
+      }
+      ret = TRUE;
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      GstFormat format;
+      gdouble rate;
+      gint64 start, stop, time;
+      gboolean update;
+
+      GST_DEBUG_OBJECT (demux, "received new segment");
+
+      gst_event_parse_new_segment (event, &update, &rate, &format, &start,
+          &stop, &time);
+
+      if (format == GST_FORMAT_TIME) {
+        /* time segment, this is perfect, copy over the values. */
+        gst_segment_set_newsegment (demux->segment, update, rate, format, start,
+            stop, time);
+
+        GST_DEBUG_OBJECT (demux, "NEWSEGMENT: %" GST_SEGMENT_FORMAT,
+            demux->segment);
+
+        /* and forward */
+        ret = gst_pad_event_default (demux->sinkpad, event);
+      } else {
+        /* non-time format */
+        demux->audio_need_segment = TRUE;
+        demux->video_need_segment = TRUE;
+        ret = TRUE;
+        gst_event_unref (event);
+      }
+      break;
+    }
+    default:
+      ret = gst_pad_event_default (demux->sinkpad, event);
+      break;
+  }
+
+  gst_object_unref (demux);
+
+  return ret;
+}
+
+gboolean
+gst_flv_demux_src_event (GstPad * pad, GstEvent * event)
+{
+  GstFLVDemux *demux;
+  gboolean ret = FALSE;
+
+  demux = GST_FLV_DEMUX (gst_pad_get_parent (pad));
+
+  GST_DEBUG_OBJECT (demux, "handling event %s", GST_EVENT_TYPE_NAME (event));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_SEEK:
+      if (demux->random_access) {
+        ret = gst_flv_demux_handle_seek_pull (demux, event);
+      } else {
+        ret = gst_flv_demux_handle_seek_push (demux, event);
+      }
+      break;
+    default:
+      ret = gst_pad_push_event (demux->sinkpad, event);
+      break;
+  }
+
+  gst_object_unref (demux);
+
+  return ret;
+}
+
+gboolean
+gst_flv_demux_query (GstPad * pad, GstQuery * query)
+{
+  gboolean res = TRUE;
+  GstFLVDemux *demux;
+
+  demux = GST_FLV_DEMUX (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_DURATION:
+    {
+      GstFormat format;
+
+      gst_query_parse_duration (query, &format, NULL);
+
+      /* duration is time only */
+      if (format != GST_FORMAT_TIME) {
+        GST_DEBUG_OBJECT (demux, "duration query only supported for time "
+            "format");
+        res = FALSE;
+        goto beach;
+      }
+
+      GST_DEBUG_OBJECT (pad, "duration query, replying %" GST_TIME_FORMAT,
+          GST_TIME_ARGS (demux->duration));
+
+      gst_query_set_duration (query, GST_FORMAT_TIME, demux->duration);
+
+      break;
+    }
+    case GST_QUERY_LATENCY:
+    {
+      GstPad *peer;
+
+      if ((peer = gst_pad_get_peer (demux->sinkpad))) {
+        /* query latency on peer pad */
+        res = gst_pad_query (peer, query);
+        gst_object_unref (peer);
+      } else {
+        /* no peer, we don't know */
+        res = FALSE;
+      }
+      break;
+    }
+    default:
+      res = FALSE;
+      break;
+  }
+
+beach:
+  gst_object_unref (demux);
+
+  return res;
+}
+
+static GstStateChangeReturn
+gst_flv_demux_change_state (GstElement * element, GstStateChange transition)
+{
+  GstFLVDemux *demux;
+  GstStateChangeReturn ret;
+
+  demux = GST_FLV_DEMUX (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      /* If no index was created, generate one */
+      if (G_UNLIKELY (!demux->index)) {
+        GST_DEBUG_OBJECT (demux, "no index provided creating our own");
+
+        demux->index = gst_index_factory_make ("memindex");
+
+        gst_index_get_writer_id (demux->index, GST_OBJECT (demux),
+            &demux->index_id);
+      }
+      gst_flv_demux_cleanup (demux);
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+  if (ret == GST_STATE_CHANGE_FAILURE)
+    return ret;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_flv_demux_cleanup (demux);
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static void
+gst_flv_demux_set_index (GstElement * element, GstIndex * index)
+{
+  GstFLVDemux *demux = GST_FLV_DEMUX (element);
+
+  GST_OBJECT_LOCK (demux);
+  if (demux->index)
+    gst_object_unref (demux->index);
+  demux->index = gst_object_ref (index);
+  GST_OBJECT_UNLOCK (demux);
+
+  gst_index_get_writer_id (index, GST_OBJECT (element), &demux->index_id);
+}
+
+static GstIndex *
+gst_flv_demux_get_index (GstElement * element)
+{
+  GstIndex *result = NULL;
+
+  GstFLVDemux *demux = GST_FLV_DEMUX (element);
+
+  GST_OBJECT_LOCK (demux);
+  if (demux->index)
+    result = gst_object_ref (demux->index);
+  GST_OBJECT_UNLOCK (demux);
+
+  return result;
+}
+
+static void
+gst_flv_demux_dispose (GObject * object)
+{
+  GstFLVDemux *demux = GST_FLV_DEMUX (object);
+
+  GST_DEBUG_OBJECT (demux, "disposing FLV demuxer");
+
+  if (demux->adapter) {
+    gst_adapter_clear (demux->adapter);
+    g_object_unref (demux->adapter);
+    demux->adapter = NULL;
+  }
+
+  if (demux->segment) {
+    gst_segment_free (demux->segment);
+    demux->segment = NULL;
+  }
+
+  if (demux->taglist) {
+    gst_tag_list_free (demux->taglist);
+    demux->taglist = NULL;
+  }
+
+  if (demux->new_seg_event) {
+    gst_event_unref (demux->new_seg_event);
+    demux->new_seg_event = NULL;
+  }
+
+  if (demux->audio_pad) {
+    gst_object_unref (demux->audio_pad);
+    demux->audio_pad = NULL;
+  }
+
+  if (demux->video_pad) {
+    gst_object_unref (demux->video_pad);
+    demux->video_pad = NULL;
+  }
+
+  if (demux->index) {
+    gst_object_unref (demux->index);
+    demux->index = NULL;
+  }
+
+  if (demux->times) {
+    g_array_free (demux->times, TRUE);
+    demux->times = NULL;
+  }
+
+  if (demux->filepositions) {
+    g_array_free (demux->filepositions, TRUE);
+    demux->filepositions = NULL;
+  }
+
+  GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
+}
+
+static void
+gst_flv_demux_base_init (gpointer g_class)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&flv_sink_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&audio_src_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&video_src_template));
+  gst_element_class_set_details (element_class, &flv_demux_details);
+}
+
+static void
+gst_flv_demux_class_init (GstFLVDemuxClass * klass)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  gobject_class->dispose = GST_DEBUG_FUNCPTR (gst_flv_demux_dispose);
+
+  gstelement_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_flv_demux_change_state);
+  gstelement_class->set_index = GST_DEBUG_FUNCPTR (gst_flv_demux_set_index);
+  gstelement_class->get_index = GST_DEBUG_FUNCPTR (gst_flv_demux_get_index);
+}
+
+static void
+gst_flv_demux_init (GstFLVDemux * demux, GstFLVDemuxClass * g_class)
+{
+  demux->sinkpad =
+      gst_pad_new_from_static_template (&flv_sink_template, "sink");
+
+  gst_pad_set_event_function (demux->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_flv_demux_sink_event));
+  gst_pad_set_chain_function (demux->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_flv_demux_chain));
+  gst_pad_set_activate_function (demux->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_flv_demux_sink_activate));
+  gst_pad_set_activatepull_function (demux->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_flv_demux_sink_activate_pull));
+  gst_pad_set_activatepush_function (demux->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_flv_demux_sink_activate_push));
+
+  gst_element_add_pad (GST_ELEMENT (demux), demux->sinkpad);
+
+  demux->adapter = gst_adapter_new ();
+  demux->segment = gst_segment_new ();
+  demux->taglist = gst_tag_list_new ();
+  gst_segment_init (demux->segment, GST_FORMAT_TIME);
+
+  gst_flv_demux_cleanup (demux);
+}
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  GST_DEBUG_CATEGORY_INIT (flvdemux_debug, "flvdemux", 0, "FLV demuxer");
+
+  if (!gst_element_register (plugin, "flvdemux", GST_RANK_PRIMARY,
+          gst_flv_demux_get_type ()))
+    return FALSE;
+
+  return TRUE;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR, GST_VERSION_MINOR,
+    "flvdemux", "Element demuxing FLV stream",
+    plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff -up /dev/null gst-plugins-bad-0.10.5/gst/flv/gstflvdemux.h
--- /dev/null	2008-02-05 09:36:22.221546318 +0100
+++ gst-plugins-bad-0.10.5/gst/flv/gstflvdemux.h	2008-02-05 10:33:21.000000000 +0100
@@ -0,0 +1,124 @@
+/* GStreamer
+ * Copyright (C) <2007> Julien Moutte <julien@moutte.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __FLV_DEMUX_H__
+#define __FLV_DEMUX_H__
+
+#include <gst/gst.h>
+#include <gst/base/gstadapter.h>
+
+G_BEGIN_DECLS
+#define GST_TYPE_FLV_DEMUX \
+  (gst_flv_demux_get_type())
+#define GST_FLV_DEMUX(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FLV_DEMUX,GstFLVDemux))
+#define GST_FLV_DEMUX_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FLV_DEMUX,GstFLVDemuxClass))
+#define GST_IS_FLV_DEMUX(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FLV_DEMUX))
+#define GST_IS_FLV_DEMUX_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FLV_DEMUX))
+typedef struct _GstFLVDemux GstFLVDemux;
+typedef struct _GstFLVDemuxClass GstFLVDemuxClass;
+
+typedef enum
+{
+  FLV_STATE_HEADER,
+  FLV_STATE_TAG_TYPE,
+  FLV_STATE_TAG_VIDEO,
+  FLV_STATE_TAG_AUDIO,
+  FLV_STATE_TAG_SCRIPT,
+  FLV_STATE_DONE,
+  FLV_STATE_NONE
+} GstFLVDemuxState;
+
+struct _GstFLVDemux
+{
+  GstElement element;
+
+  GstPad *sinkpad;
+
+  GstPad *audio_pad;
+  GstPad *video_pad;
+  
+  GstIndex *index;
+  gint index_id;
+  
+  GArray * times;
+  GArray * filepositions;
+
+  GstAdapter *adapter;
+
+  GstSegment *segment;
+
+  GstEvent *new_seg_event;
+
+  GstTagList *taglist;
+
+  GstFLVDemuxState state;
+
+  guint64 offset;
+  guint64 cur_tag_offset;
+  GstClockTime duration;
+  guint64 tag_size;
+  guint64 tag_data_size;
+
+  /* Audio infos */
+  guint16 rate;
+  guint16 channels;
+  guint16 width;
+  guint16 audio_codec_tag;
+  guint64 audio_offset;
+  gboolean audio_need_discont;
+  gboolean audio_need_segment;
+  gboolean audio_linked;
+
+  /* Video infos */
+  guint32 w;
+  guint32 h;
+  guint32 par_x;
+  guint32 par_y;
+  guint16 video_codec_tag;
+  guint64 video_offset;
+  gboolean video_need_discont;
+  gboolean video_need_segment;
+  gboolean video_linked;
+  gboolean got_par;
+
+  gboolean random_access;
+  gboolean need_header;
+  gboolean has_audio;
+  gboolean has_video;
+  gboolean push_tags;
+  gboolean strict;
+  gboolean flushing;
+};
+
+struct _GstFLVDemuxClass
+{
+  GstElementClass parent_class;
+};
+
+GType gst_flv_demux_get_type (void);
+
+gboolean gst_flv_demux_query (GstPad * pad, GstQuery * query);
+gboolean gst_flv_demux_src_event (GstPad * pad, GstEvent * event);
+
+G_END_DECLS
+#endif /* __FLV_DEMUX_H__ */
diff -up /dev/null gst-plugins-bad-0.10.5/gst/flv/CVS/Root
--- /dev/null	2008-02-05 09:36:22.221546318 +0100
+++ gst-plugins-bad-0.10.5/gst/flv/CVS/Root	2008-02-05 10:33:21.000000000 +0100
@@ -0,0 +1 @@
+:pserver:anoncvs@anoncvs.freedesktop.org:/cvs/gstreamer
diff -up /dev/null gst-plugins-bad-0.10.5/gst/flv/CVS/Entries
--- /dev/null	2008-02-05 09:36:22.221546318 +0100
+++ gst-plugins-bad-0.10.5/gst/flv/CVS/Entries	2008-02-05 10:33:21.000000000 +0100
@@ -0,0 +1,6 @@
+/Makefile.am/1.1/Thu Jul 19 15:05:30 2007//
+/gstflvdemux.c/1.10/Wed Sep 12 08:38:21 2007//
+/gstflvdemux.h/1.5/Fri Aug 24 15:31:26 2007//
+/gstflvparse.c/1.14/Tue Dec 11 11:54:43 2007//
+/gstflvparse.h/1.2/Wed Jul 25 13:29:04 2007//
+D
diff -up /dev/null gst-plugins-bad-0.10.5/gst/flv/CVS/Repository
--- /dev/null	2008-02-05 09:36:22.221546318 +0100
+++ gst-plugins-bad-0.10.5/gst/flv/CVS/Repository	2008-02-05 10:33:21.000000000 +0100
@@ -0,0 +1 @@
+gst-plugins-bad/gst/flv
diff -up /dev/null gst-plugins-bad-0.10.5/gst/flv/gstflvparse.h
--- /dev/null	2008-02-05 09:36:22.221546318 +0100
+++ gst-plugins-bad-0.10.5/gst/flv/gstflvparse.h	2008-02-05 10:33:21.000000000 +0100
@@ -0,0 +1,42 @@
+/* GStreamer
+ * Copyright (C) <2007> Julien Moutte <julien@moutte.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __FLV_PARSE_H__
+#define __FLV_PARSE_H__
+
+#include "gstflvdemux.h"
+
+G_BEGIN_DECLS
+    GstFlowReturn gst_flv_parse_tag_script (GstFLVDemux * demux,
+    const guint8 * data, size_t data_size);
+
+GstFlowReturn gst_flv_parse_tag_audio (GstFLVDemux * demux, const guint8 * data,
+    size_t data_size);
+
+GstFlowReturn gst_flv_parse_tag_video (GstFLVDemux * demux, const guint8 * data,
+    size_t data_size);
+
+GstFlowReturn gst_flv_parse_tag_type (GstFLVDemux * demux, const guint8 * data,
+    size_t data_size);
+
+GstFlowReturn gst_flv_parse_header (GstFLVDemux * demux, const guint8 * data,
+    size_t data_size);
+
+G_END_DECLS
+#endif /* __FLV_PARSE_H__ */
diff -up /dev/null gst-plugins-bad-0.10.5/gst/flv/Makefile.am
--- /dev/null	2008-02-05 09:36:22.221546318 +0100
+++ gst-plugins-bad-0.10.5/gst/flv/Makefile.am	2008-02-05 10:33:21.000000000 +0100
@@ -0,0 +1,9 @@
+
+plugin_LTLIBRARIES = libgstflvdemux.la
+
+libgstflvdemux_la_CFLAGS = ${GST_CFLAGS}
+libgstflvdemux_la_LIBADD = $(GST_BASE_LIBS)
+libgstflvdemux_la_LDFLAGS = ${GST_PLUGIN_LDFLAGS} 
+libgstflvdemux_la_SOURCES = gstflvdemux.c gstflvparse.c
+
+noinst_HEADERS = gstflvdemux.h gstflvparse.h
diff -up /dev/null gst-plugins-bad-0.10.5/gst/flv/gstflvparse.c
--- /dev/null	2008-02-05 09:36:22.221546318 +0100
+++ gst-plugins-bad-0.10.5/gst/flv/gstflvparse.c	2008-02-05 10:33:21.000000000 +0100
@@ -0,0 +1,1027 @@
+/* GStreamer
+ * Copyright (C) <2007> Julien Moutte <julien@moutte.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "gstflvparse.h"
+
+#include <string.h>
+
+GST_DEBUG_CATEGORY_EXTERN (flvdemux_debug);
+#define GST_CAT_DEFAULT flvdemux_debug
+
+static guint32
+FLV_GET_BEUI24 (const guint8 * data, size_t data_size)
+{
+  guint32 ret = 0;
+
+  g_return_val_if_fail (data != NULL, 0);
+  g_return_val_if_fail (data_size >= 3, 0);
+
+  ret = GST_READ_UINT16_BE (data) << 8;
+  ret |= GST_READ_UINT8 (data + 2);
+
+  return ret;
+}
+
+static gchar *
+FLV_GET_STRING (const guint8 * data, size_t data_size)
+{
+  guint32 string_size = 0;
+  gchar *string = NULL;
+
+  g_return_val_if_fail (data != NULL, NULL);
+  g_return_val_if_fail (data_size >= 2, NULL);
+
+  string_size = GST_READ_UINT16_BE (data);
+  if (G_UNLIKELY (string_size > data_size)) {
+    return NULL;
+  }
+
+  string = g_try_malloc0 (string_size + 1);
+  if (G_UNLIKELY (!string)) {
+    return NULL;
+  }
+
+  memcpy (string, data + 2, string_size);
+
+  return string;
+}
+
+static const GstQueryType *
+gst_flv_demux_query_types (GstPad * pad)
+{
+  static const GstQueryType query_types[] = {
+    GST_QUERY_DURATION,
+    0
+  };
+
+  return query_types;
+}
+
+static size_t
+gst_flv_parse_metadata_item (GstFLVDemux * demux, const guint8 * data,
+    size_t data_size, gboolean * end_marker)
+{
+  gchar *tag_name = NULL;
+  guint8 tag_type = 0;
+  size_t offset = 0;
+
+  /* Initialize the end_marker flag to FALSE */
+  *end_marker = FALSE;
+
+  /* Name of the tag */
+  tag_name = FLV_GET_STRING (data, data_size);
+  if (G_UNLIKELY (!tag_name)) {
+    GST_WARNING_OBJECT (demux, "failed reading tag name");
+    goto beach;
+  }
+
+  offset += strlen (tag_name) + 2;
+
+  /* What kind of object is that */
+  tag_type = GST_READ_UINT8 (data + offset);
+
+  offset++;
+
+  GST_DEBUG_OBJECT (demux, "tag name %s, tag type %d", tag_name, tag_type);
+
+  switch (tag_type) {
+    case 0:                    // Double
+    {                           /* Use a union to read the uint64 and then as a double */
+      union
+      {
+        guint64 value_uint64;
+        gdouble value_double;
+      } value_union;
+
+      value_union.value_uint64 = GST_READ_UINT64_BE (data + offset);
+
+      offset += 8;
+
+      GST_DEBUG_OBJECT (demux, "%s => (double) %f", tag_name,
+          value_union.value_double);
+
+      if (!strcmp (tag_name, "duration")) {
+        demux->duration = value_union.value_double * GST_SECOND;
+
+        gst_tag_list_add (demux->taglist, GST_TAG_MERGE_REPLACE,
+            GST_TAG_DURATION, demux->duration, NULL);
+      } else {
+        if (tag_name) {
+          if (!strcmp (tag_name, "AspectRatioX")) {
+            demux->par_x = value_union.value_double;
+            demux->got_par = TRUE;
+          } else if (!strcmp (tag_name, "AspectRatioY")) {
+            demux->par_y = value_union.value_double;
+            demux->got_par = TRUE;
+          }
+          if (!gst_tag_exists (tag_name)) {
+            gst_tag_register (tag_name, GST_TAG_FLAG_META, G_TYPE_DOUBLE,
+                tag_name, tag_name, gst_tag_merge_use_first);
+          }
+
+          if (gst_tag_get_type (tag_name) == G_TYPE_DOUBLE) {
+            gst_tag_list_add (demux->taglist, GST_TAG_MERGE_REPLACE,
+                tag_name, value_union.value_double, NULL);
+          } else {
+            GST_WARNING_OBJECT (demux, "tag %s already registered with a "
+                "different type", tag_name);
+          }
+        }
+      }
+
+      break;
+    }
+    case 1:                    // Boolean
+    {
+      gboolean value = GST_READ_UINT8 (data + offset);
+
+      offset++;
+
+      GST_DEBUG_OBJECT (demux, "%s => (boolean) %d", tag_name, value);
+
+      if (tag_name) {
+        if (!gst_tag_exists (tag_name)) {
+          gst_tag_register (tag_name, GST_TAG_FLAG_META, G_TYPE_BOOLEAN,
+              tag_name, tag_name, gst_tag_merge_use_first);
+        }
+
+        if (gst_tag_get_type (tag_name) == G_TYPE_BOOLEAN) {
+          gst_tag_list_add (demux->taglist, GST_TAG_MERGE_REPLACE,
+              tag_name, value, NULL);
+        } else {
+          GST_WARNING_OBJECT (demux, "tag %s already registered with a "
+              "different type", tag_name);
+        }
+      }
+
+      break;
+    }
+    case 2:                    // String
+    {
+      gchar *value = NULL;
+
+      value = FLV_GET_STRING (data + offset, data_size - offset);
+
+      offset += strlen (value) + 2;
+
+      GST_DEBUG_OBJECT (demux, "%s => (string) %s", tag_name, value);
+
+      if (tag_name) {
+        if (!gst_tag_exists (tag_name)) {
+          gst_tag_register (tag_name, GST_TAG_FLAG_META, G_TYPE_STRING,
+              tag_name, tag_name, gst_tag_merge_strings_with_comma);
+        }
+
+        if (gst_tag_get_type (tag_name) == G_TYPE_STRING) {
+          gst_tag_list_add (demux->taglist, GST_TAG_MERGE_REPLACE,
+              tag_name, value, NULL);
+        } else {
+          GST_WARNING_OBJECT (demux, "tag %s already registered with a "
+              "different type", tag_name);
+        }
+      }
+
+      g_free (value);
+
+      break;
+    }
+    case 3:                    // Object
+    {
+      gboolean end_of_object_marker = FALSE;
+
+      while (!end_of_object_marker && offset < data_size) {
+        size_t read = gst_flv_parse_metadata_item (demux, data + offset,
+            data_size - offset, &end_of_object_marker);
+
+        if (G_UNLIKELY (!read)) {
+          GST_WARNING_OBJECT (demux, "failed reading a tag, skipping");
+          break;
+        }
+
+        offset += read;
+      }
+
+      break;
+    }
+    case 9:                    // End marker
+    {
+      GST_DEBUG_OBJECT (demux, "end marker ?");
+      if (tag_name[0] == '\0') {
+
+        GST_DEBUG_OBJECT (demux, "end marker detected");
+
+        *end_marker = TRUE;
+      }
+
+      break;
+    }
+    case 10:                   // Array
+    {
+      guint32 nb_elems = GST_READ_UINT32_BE (data + offset);
+
+      offset += 4;
+
+      GST_DEBUG_OBJECT (demux, "array has %d elements", nb_elems);
+
+      if (!strcmp (tag_name, "times")) {
+        if (demux->times) {
+          g_array_free (demux->times, TRUE);
+        }
+        demux->times = g_array_new (FALSE, TRUE, sizeof (gdouble));
+      } else if (!strcmp (tag_name, "filepositions")) {
+        if (demux->filepositions) {
+          g_array_free (demux->filepositions, TRUE);
+        }
+        demux->filepositions = g_array_new (FALSE, TRUE, sizeof (gdouble));
+      }
+
+      while (nb_elems--) {
+        guint8 elem_type = GST_READ_UINT8 (data + offset);
+
+        offset++;
+
+        switch (elem_type) {
+          case 0:
+          {
+            union
+            {
+              guint64 value_uint64;
+              gdouble value_double;
+            } value_union;
+
+            value_union.value_uint64 = GST_READ_UINT64_BE (data + offset);
+
+            offset += 8;
+
+            GST_DEBUG_OBJECT (demux, "element is a double %f",
+                value_union.value_double);
+
+            if (!strcmp (tag_name, "times") && demux->times) {
+              g_array_append_val (demux->times, value_union.value_double);
+            } else if (!strcmp (tag_name, "filepositions") &&
+                demux->filepositions) {
+              g_array_append_val (demux->filepositions,
+                  value_union.value_double);
+            }
+            break;
+          }
+          default:
+            GST_WARNING_OBJECT (demux, "unsupported array element type %d",
+                elem_type);
+        }
+      }
+
+      break;
+    }
+    case 11:                   // Date
+    {
+      union
+      {
+        guint64 value_uint64;
+        gdouble value_double;
+      } value_union;
+
+      value_union.value_uint64 = GST_READ_UINT64_BE (data + offset);
+
+      offset += 8;
+
+      /* There are 2 additional bytes */
+      offset += 2;
+
+      GST_DEBUG_OBJECT (demux, "%s => (date as a double) %f", tag_name,
+          value_union.value_double);
+
+      break;
+    }
+    default:
+      GST_WARNING_OBJECT (demux, "unsupported tag type %d", tag_type);
+  }
+
+  g_free (tag_name);
+
+beach:
+  return offset;
+}
+
+GstFlowReturn
+gst_flv_parse_tag_script (GstFLVDemux * demux, const guint8 * data,
+    size_t data_size)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+  size_t offset = 7;
+
+  GST_LOG_OBJECT (demux, "parsing a script tag");
+
+  if (GST_READ_UINT8 (data + offset++) == 2) {
+    guint i;
+    gchar *function_name = FLV_GET_STRING (data + offset, data_size - offset);
+
+    GST_LOG_OBJECT (demux, "function name is %s", function_name);
+
+    if (!strcmp (function_name, "onMetaData")) {
+      guint32 nb_elems = 0;
+      gboolean end_marker = FALSE;
+
+      GST_DEBUG_OBJECT (demux, "we have a metadata script object");
+
+      /* Jump over the onMetaData string and the array indicator */
+      offset += 13;
+
+      nb_elems = GST_READ_UINT32_BE (data + offset);
+
+      /* Jump over the number of elements */
+      offset += 4;
+
+      GST_DEBUG_OBJECT (demux, "there are %d elements in the array", nb_elems);
+
+      while (nb_elems-- && !end_marker) {
+        size_t read = gst_flv_parse_metadata_item (demux, data + offset,
+            data_size - offset, &end_marker);
+
+        if (G_UNLIKELY (!read)) {
+          GST_WARNING_OBJECT (demux, "failed reading a tag, skipping");
+          break;
+        }
+        offset += read;
+      }
+
+      demux->push_tags = TRUE;
+    }
+
+    g_free (function_name);
+
+    if (demux->index && demux->times && demux->filepositions) {
+      /* If an index was found, insert associations */
+      for (i = 0; i < MIN (demux->times->len, demux->filepositions->len); i++) {
+        guint64 time, fileposition;
+
+        time = g_array_index (demux->times, gdouble, i) * GST_SECOND;
+        fileposition = g_array_index (demux->filepositions, gdouble, i);
+        GST_LOG_OBJECT (demux, "adding association %" GST_TIME_FORMAT "-> %"
+            G_GUINT64_FORMAT, GST_TIME_ARGS (time), fileposition);
+        gst_index_add_association (demux->index, demux->index_id,
+            GST_ASSOCIATION_FLAG_KEY_UNIT, GST_FORMAT_TIME, time,
+            GST_FORMAT_BYTES, fileposition, NULL);
+      }
+    }
+  }
+
+
+  return ret;
+}
+
+GstFlowReturn
+gst_flv_parse_tag_audio (GstFLVDemux * demux, const guint8 * data,
+    size_t data_size)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+  GstBuffer *buffer = NULL;
+  guint32 pts = 0, codec_tag = 0, rate = 5512, width = 8, channels = 1;
+  guint32 codec_data = 0, pts_ext = 0;
+  guint8 flags = 0;
+
+  GST_LOG_OBJECT (demux, "parsing an audio tag");
+
+  GST_LOG_OBJECT (demux, "pts bytes %02X %02X %02X %02X", data[0], data[1],
+      data[2], data[3]);
+
+  /* Grab information about audio tag */
+  pts = FLV_GET_BEUI24 (data, data_size);
+  /* read the pts extension to 32 bits integer */
+  pts_ext = GST_READ_UINT8 (data + 3);
+  /* Combine them */
+  pts |= pts_ext << 24;
+  /* Skip the stream id and go directly to the flags */
+  flags = GST_READ_UINT8 (data + 7);
+
+  /* Channels */
+  if (flags & 0x01) {
+    channels = 2;
+  }
+  /* Width */
+  if (flags & 0x02) {
+    width = 16;
+  }
+  /* Sampling rate */
+  if ((flags & 0x0C) == 0x0C) {
+    rate = 44100;
+  } else if ((flags & 0x0C) == 0x08) {
+    rate = 22050;
+  } else if ((flags & 0x0C) == 0x04) {
+    rate = 11025;
+  }
+  /* Codec tag */
+  codec_tag = flags >> 4;
+  codec_data = 1;
+
+  GST_LOG_OBJECT (demux, "audio tag with %d channels, %dHz sampling rate, "
+      "%d bits width, codec tag %u (flags %02X)", channels, rate, width,
+      codec_tag, flags);
+
+  /* If we don't have our audio pad created, then create it. */
+  if (G_UNLIKELY (!demux->audio_pad)) {
+    GstCaps *caps = NULL;
+    gchar *codec_name = NULL;
+
+    demux->audio_pad = gst_pad_new ("audio", GST_PAD_SRC);
+    if (G_UNLIKELY (!demux->audio_pad)) {
+      GST_WARNING_OBJECT (demux, "failed creating audio pad");
+      ret = GST_FLOW_ERROR;
+      goto beach;
+    }
+
+    /* Make it active */
+    gst_pad_set_active (demux->audio_pad, TRUE);
+
+    switch (codec_tag) {
+      case 1:
+        caps =
+            gst_caps_new_simple ("audio/x-adpcm", "layout", G_TYPE_STRING,
+            "swf", NULL);
+        codec_name = "Shockwave ADPCM";
+        break;
+      case 2:
+        caps = gst_caps_new_simple ("audio/mpeg",
+            "mpegversion", G_TYPE_INT, 1, "layer", G_TYPE_INT, 3, NULL);
+        codec_name = "MPEG 1 Audio, Layer 3 (MP3)";
+        break;
+      case 0:
+      case 3:
+        caps = gst_caps_new_simple ("audio/x-raw-int",
+            "endianness", G_TYPE_INT, G_BYTE_ORDER,
+            "signed", G_TYPE_BOOLEAN, TRUE,
+            "width", G_TYPE_INT, width, "depth", G_TYPE_INT, width, NULL);
+        codec_name = "Raw Audio";
+        break;
+      case 5:
+      case 6:
+        caps = gst_caps_new_simple ("audio/x-nellymoser", NULL);
+        codec_name = "Nellymoser ASAO";
+        break;
+      default:
+        GST_WARNING_OBJECT (demux, "unsupported audio codec tag %u", codec_tag);
+    }
+
+    if (G_UNLIKELY (!caps)) {
+      GST_WARNING_OBJECT (demux, "failed creating caps for audio pad");
+      ret = GST_FLOW_ERROR;
+      gst_object_unref (demux->audio_pad);
+      demux->audio_pad = NULL;
+      goto beach;
+    }
+
+    gst_caps_set_simple (caps,
+        "rate", G_TYPE_INT, rate, "channels", G_TYPE_INT, channels, NULL);
+
+    gst_pad_set_caps (demux->audio_pad, caps);
+    if (codec_name) {
+      if (demux->taglist == NULL)
+        demux->taglist = gst_tag_list_new ();
+      gst_tag_list_add (demux->taglist, GST_TAG_MERGE_REPLACE,
+          GST_TAG_AUDIO_CODEC, codec_name, NULL);
+    }
+
+    GST_DEBUG_OBJECT (demux, "created audio pad with caps %" GST_PTR_FORMAT,
+        caps);
+
+    gst_caps_unref (caps);
+
+    /* Store the caps we have set */
+    demux->audio_codec_tag = codec_tag;
+    demux->rate = rate;
+    demux->channels = channels;
+    demux->width = width;
+
+    /* Set functions on the pad */
+    gst_pad_set_query_type_function (demux->audio_pad,
+        GST_DEBUG_FUNCPTR (gst_flv_demux_query_types));
+    gst_pad_set_query_function (demux->audio_pad,
+        GST_DEBUG_FUNCPTR (gst_flv_demux_query));
+    gst_pad_set_event_function (demux->audio_pad,
+        GST_DEBUG_FUNCPTR (gst_flv_demux_src_event));
+
+    /* We need to set caps before adding */
+    gst_element_add_pad (GST_ELEMENT (demux),
+        gst_object_ref (demux->audio_pad));
+
+    /* We only emit no more pads when we have audio and video. Indeed we can
+     * not trust the FLV header to tell us if there will be only audio or 
+     * only video and we would just break discovery of some files */
+    if (demux->audio_pad && demux->video_pad) {
+      GST_DEBUG_OBJECT (demux, "emitting no more pads");
+      gst_element_no_more_pads (GST_ELEMENT (demux));
+    }
+  }
+
+  /* Check if caps have changed */
+  if (G_UNLIKELY (rate != demux->rate || channels != demux->channels ||
+          codec_tag != demux->audio_codec_tag || width != demux->width)) {
+    GstCaps *caps = NULL;
+    gchar *codec_name = NULL;
+
+    GST_DEBUG_OBJECT (demux, "audio settings have changed, changing caps");
+
+    switch (codec_tag) {
+      case 1:
+        caps =
+            gst_caps_new_simple ("audio/x-adpcm", "layout", G_TYPE_STRING,
+            "swf", NULL);
+        codec_name = "Shockwave ADPCM";
+        break;
+      case 2:
+        caps = gst_caps_new_simple ("audio/mpeg",
+            "mpegversion", G_TYPE_INT, 1, "layer", G_TYPE_INT, 3, NULL);
+        codec_name = "MPEG 1 Audio, Layer 3 (MP3)";
+        break;
+      case 0:
+      case 3:
+        caps = gst_caps_new_simple ("audio/x-raw-int", NULL);
+        codec_name = "Raw Audio";
+        break;
+      case 6:
+        caps = gst_caps_new_simple ("audio/x-nellymoser", NULL);
+        codec_name = "Nellymoser ASAO";
+        break;
+      default:
+        GST_WARNING_OBJECT (demux, "unsupported audio codec tag %u", codec_tag);
+    }
+
+    if (G_UNLIKELY (!caps)) {
+      GST_WARNING_OBJECT (demux, "failed creating caps for audio pad");
+      ret = GST_FLOW_ERROR;
+      goto beach;
+    }
+
+    gst_caps_set_simple (caps,
+        "rate", G_TYPE_INT, rate,
+        "channels", G_TYPE_INT, channels, "width", G_TYPE_INT, width, NULL);
+
+    gst_pad_set_caps (demux->audio_pad, caps);
+    if (codec_name) {
+      if (demux->taglist == NULL)
+        demux->taglist = gst_tag_list_new ();
+      gst_tag_list_add (demux->taglist, GST_TAG_MERGE_REPLACE,
+          GST_TAG_AUDIO_CODEC, codec_name, NULL);
+    }
+
+    gst_caps_unref (caps);
+
+    /* Store the caps we have set */
+    demux->audio_codec_tag = codec_tag;
+    demux->rate = rate;
+    demux->channels = channels;
+    demux->width = width;
+  }
+
+  /* Push taglist if present */
+  if ((demux->has_audio && !demux->audio_pad) ||
+      (demux->has_video && !demux->video_pad)) {
+    GST_DEBUG_OBJECT (demux, "we are still waiting for a stream to come up "
+        "before we can push tags");
+  } else {
+    if (demux->taglist && demux->push_tags) {
+      GST_DEBUG_OBJECT (demux, "pushing tags out");
+      gst_element_found_tags (GST_ELEMENT (demux), demux->taglist);
+      demux->taglist = gst_tag_list_new ();
+      demux->push_tags = FALSE;
+    }
+  }
+
+  /* Check if we have anything to push */
+  if (demux->tag_data_size <= codec_data) {
+    GST_LOG_OBJECT (demux, "Nothing left in this tag, returning");
+    goto beach;
+  }
+
+  /* Create buffer from pad */
+  ret = gst_pad_alloc_buffer (demux->audio_pad, GST_BUFFER_OFFSET_NONE,
+      demux->tag_data_size - codec_data, GST_PAD_CAPS (demux->audio_pad),
+      &buffer);
+  if (G_UNLIKELY (ret != GST_FLOW_OK)) {
+    GST_WARNING_OBJECT (demux, "failed allocating a %" G_GUINT64_FORMAT
+        " bytes buffer: %s", demux->tag_data_size, gst_flow_get_name (ret));
+    if (ret == GST_FLOW_NOT_LINKED) {
+      demux->audio_linked = FALSE;
+    }
+    goto beach;
+  }
+
+  demux->audio_linked = TRUE;
+
+  /* Fill buffer with data */
+  GST_BUFFER_TIMESTAMP (buffer) = pts * GST_MSECOND;
+  GST_BUFFER_DURATION (buffer) = GST_CLOCK_TIME_NONE;
+  GST_BUFFER_OFFSET (buffer) = demux->audio_offset++;
+  GST_BUFFER_OFFSET_END (buffer) = demux->audio_offset;
+
+  if (G_UNLIKELY (demux->audio_need_discont)) {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+    demux->audio_need_discont = FALSE;
+  }
+
+  gst_segment_set_last_stop (demux->segment, GST_FORMAT_TIME,
+      GST_BUFFER_TIMESTAMP (buffer));
+
+  /* Do we need a newsegment event ? */
+  if (G_UNLIKELY (demux->audio_need_segment)) {
+    if (!demux->new_seg_event) {
+      GST_DEBUG_OBJECT (demux, "pushing newsegment from %"
+          GST_TIME_FORMAT " to %" GST_TIME_FORMAT,
+          GST_TIME_ARGS (demux->segment->last_stop),
+          GST_TIME_ARGS (demux->segment->stop));
+      demux->new_seg_event =
+          gst_event_new_new_segment (FALSE, demux->segment->rate,
+          demux->segment->format, demux->segment->last_stop,
+          demux->segment->stop, demux->segment->last_stop);
+    } else {
+      GST_DEBUG_OBJECT (demux, "pushing pre-generated newsegment event");
+    }
+
+    gst_pad_push_event (demux->audio_pad, gst_event_ref (demux->new_seg_event));
+
+    demux->audio_need_segment = FALSE;
+  }
+
+  memcpy (GST_BUFFER_DATA (buffer), data + 7 + codec_data,
+      demux->tag_data_size - codec_data);
+
+  GST_LOG_OBJECT (demux, "pushing %d bytes buffer at pts %" GST_TIME_FORMAT
+      " with duration %" GST_TIME_FORMAT ", offset %" G_GUINT64_FORMAT,
+      GST_BUFFER_SIZE (buffer), GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
+      GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)), GST_BUFFER_OFFSET (buffer));
+
+  /* Push downstream */
+  ret = gst_pad_push (demux->audio_pad, buffer);
+
+beach:
+  return ret;
+}
+
+GstFlowReturn
+gst_flv_parse_tag_video (GstFLVDemux * demux, const guint8 * data,
+    size_t data_size)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+  GstBuffer *buffer = NULL;
+  guint32 pts = 0, codec_data = 1, pts_ext = 0;
+  gboolean keyframe = FALSE;
+  guint8 flags = 0, codec_tag = 0;
+
+  GST_LOG_OBJECT (demux, "parsing a video tag");
+
+  GST_LOG_OBJECT (demux, "pts bytes %02X %02X %02X %02X", data[0], data[1],
+      data[2], data[3]);
+
+  /* Grab information about video tag */
+  pts = FLV_GET_BEUI24 (data, data_size);
+  /* read the pts extension to 32 bits integer */
+  pts_ext = GST_READ_UINT8 (data + 3);
+  /* Combine them */
+  pts |= pts_ext << 24;
+  /* Skip the stream id and go directly to the flags */
+  flags = GST_READ_UINT8 (data + 7);
+
+  /* Keyframe */
+  if ((flags >> 4) == 1) {
+    keyframe = TRUE;
+  }
+  /* Codec tag */
+  codec_tag = flags & 0x0F;
+  if (codec_tag == 4 || codec_tag == 5) {
+    codec_data = 2;
+  }
+
+  GST_LOG_OBJECT (demux, "video tag with codec tag %u, keyframe (%d) "
+      "(flags %02X)", codec_tag, keyframe, flags);
+
+  /* If we don't have our video pad created, then create it. */
+  if (G_UNLIKELY (!demux->video_pad)) {
+    GstCaps *caps = NULL;
+    gchar *codec_name = NULL;
+
+    demux->video_pad = gst_pad_new ("video", GST_PAD_SRC);
+    if (G_UNLIKELY (!demux->video_pad)) {
+      GST_WARNING_OBJECT (demux, "failed creating video pad");
+      ret = GST_FLOW_ERROR;
+      goto beach;
+    }
+    /* Make it active */
+    gst_pad_set_active (demux->video_pad, TRUE);
+
+    /* Generate caps for that pad */
+    switch (codec_tag) {
+      case 2:
+        caps = gst_caps_new_simple ("video/x-flash-video", NULL);
+        codec_name = "Sorenson Video";
+        break;
+      case 3:
+        caps = gst_caps_new_simple ("video/x-flash-screen", NULL);
+        codec_name = "Flash Screen Video";
+      case 4:
+      case 5:
+        caps = gst_caps_new_simple ("video/x-vp6-flash", NULL);
+        codec_name = "On2 VP6 Video";
+        break;
+      default:
+        GST_WARNING_OBJECT (demux, "unsupported video codec tag %d", codec_tag);
+    }
+
+    if (G_UNLIKELY (!caps)) {
+      GST_WARNING_OBJECT (demux, "failed creating caps for video pad");
+      gst_object_unref (demux->video_pad);
+      demux->video_pad = NULL;
+      ret = GST_FLOW_ERROR;
+      goto beach;
+    }
+
+    gst_caps_set_simple (caps, "pixel-aspect-ratio", GST_TYPE_FRACTION,
+        demux->par_x, demux->par_y, NULL);
+
+    /* When we ve set pixel-aspect-ratio we use that boolean to detect a 
+     * metadata tag that would come later and trigger a caps change */
+    demux->got_par = FALSE;
+
+    gst_pad_set_caps (demux->video_pad, caps);
+
+    GST_DEBUG_OBJECT (demux, "created video pad with caps %" GST_PTR_FORMAT,
+        caps);
+
+    gst_caps_unref (caps);
+    if (codec_name) {
+      if (demux->taglist == NULL)
+        demux->taglist = gst_tag_list_new ();
+      gst_tag_list_add (demux->taglist, GST_TAG_MERGE_REPLACE,
+          GST_TAG_VIDEO_CODEC, codec_name, NULL);
+    }
+
+    /* Store the caps we have set */
+    demux->video_codec_tag = codec_tag;
+
+    /* Set functions on the pad */
+    gst_pad_set_query_type_function (demux->video_pad,
+        GST_DEBUG_FUNCPTR (gst_flv_demux_query_types));
+    gst_pad_set_query_function (demux->video_pad,
+        GST_DEBUG_FUNCPTR (gst_flv_demux_query));
+    gst_pad_set_event_function (demux->video_pad,
+        GST_DEBUG_FUNCPTR (gst_flv_demux_src_event));
+
+    /* We need to set caps before adding */
+    gst_element_add_pad (GST_ELEMENT (demux),
+        gst_object_ref (demux->video_pad));
+
+    /* We only emit no more pads when we have audio and video. Indeed we can
+     * not trust the FLV header to tell us if there will be only audio or 
+     * only video and we would just break discovery of some files */
+    if (demux->audio_pad && demux->video_pad) {
+      GST_DEBUG_OBJECT (demux, "emitting no more pads");
+      gst_element_no_more_pads (GST_ELEMENT (demux));
+    }
+  }
+
+  /* Check if caps have changed */
+  if (G_UNLIKELY (codec_tag != demux->video_codec_tag || demux->got_par)) {
+    GstCaps *caps = NULL;
+    gchar *codec_name = NULL;
+
+    GST_DEBUG_OBJECT (demux, "video settings have changed, changing caps");
+
+    /* Generate caps for that pad */
+    switch (codec_tag) {
+      case 2:
+        caps = gst_caps_new_simple ("video/x-flash-video", NULL);
+        codec_name = "Sorenson Video";
+        break;
+      case 3:
+        caps = gst_caps_new_simple ("video/x-flash-screen", NULL);
+        codec_name = "Flash Screen Video";
+      case 4:
+      case 5:
+        caps = gst_caps_new_simple ("video/x-vp6", NULL);
+        codec_name = "On2 VP6 Video";
+        break;
+      default:
+        GST_WARNING_OBJECT (demux, "unsupported video codec tag %d", codec_tag);
+    }
+
+    if (G_UNLIKELY (!caps)) {
+      GST_WARNING_OBJECT (demux, "failed creating caps for video pad");
+      ret = GST_FLOW_ERROR;
+      goto beach;
+    }
+
+    gst_caps_set_simple (caps, "pixel-aspect-ratio", GST_TYPE_FRACTION,
+        demux->par_x, demux->par_y, NULL);
+
+    /* When we ve set pixel-aspect-ratio we use that boolean to detect a 
+     * metadata tag that would come later and trigger a caps change */
+    demux->got_par = FALSE;
+
+    gst_pad_set_caps (demux->video_pad, caps);
+
+    gst_caps_unref (caps);
+    if (codec_name) {
+      if (demux->taglist == NULL)
+        demux->taglist = gst_tag_list_new ();
+      gst_tag_list_add (demux->taglist, GST_TAG_MERGE_REPLACE,
+          GST_TAG_VIDEO_CODEC, codec_name, NULL);
+    }
+
+    /* Store the caps we have set */
+    demux->video_codec_tag = codec_tag;
+  }
+
+  /* Push taglist if present */
+  if ((demux->has_audio && !demux->audio_pad) ||
+      (demux->has_video && !demux->video_pad)) {
+    GST_DEBUG_OBJECT (demux, "we are still waiting for a stream to come up "
+        "before we can push tags");
+  } else {
+    if (demux->taglist && demux->push_tags) {
+      GST_DEBUG_OBJECT (demux, "pushing tags out");
+      gst_element_found_tags (GST_ELEMENT (demux), demux->taglist);
+      demux->taglist = gst_tag_list_new ();
+      demux->push_tags = FALSE;
+    }
+  }
+
+  /* Check if we have anything to push */
+  if (demux->tag_data_size <= codec_data) {
+    GST_LOG_OBJECT (demux, "Nothing left in this tag, returning");
+    goto beach;
+  }
+
+  /* Create buffer from pad */
+  ret = gst_pad_alloc_buffer (demux->video_pad, GST_BUFFER_OFFSET_NONE,
+      demux->tag_data_size - codec_data, GST_PAD_CAPS (demux->video_pad),
+      &buffer);
+  if (G_UNLIKELY (ret != GST_FLOW_OK)) {
+    GST_WARNING_OBJECT (demux, "failed allocating a %" G_GUINT64_FORMAT
+        " bytes buffer: %s", demux->tag_data_size, gst_flow_get_name (ret));
+    if (ret == GST_FLOW_NOT_LINKED) {
+      demux->video_linked = FALSE;
+    }
+    goto beach;
+  }
+
+  demux->video_linked = TRUE;
+
+  /* Fill buffer with data */
+  GST_BUFFER_TIMESTAMP (buffer) = pts * GST_MSECOND;
+  GST_BUFFER_DURATION (buffer) = GST_CLOCK_TIME_NONE;
+  GST_BUFFER_OFFSET (buffer) = demux->video_offset++;
+  GST_BUFFER_OFFSET_END (buffer) = demux->video_offset;
+
+  if (!keyframe) {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    if (demux->index) {
+      GST_LOG_OBJECT (demux, "adding association %" GST_TIME_FORMAT "-> %"
+          G_GUINT64_FORMAT, GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
+          demux->cur_tag_offset);
+      gst_index_add_association (demux->index, demux->index_id,
+          GST_ASSOCIATION_FLAG_KEY_UNIT,
+          GST_FORMAT_TIME, GST_BUFFER_TIMESTAMP (buffer),
+          GST_FORMAT_BYTES, demux->cur_tag_offset, NULL);
+    }
+  }
+
+  if (G_UNLIKELY (demux->video_need_discont)) {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+    demux->video_need_discont = FALSE;
+  }
+
+  gst_segment_set_last_stop (demux->segment, GST_FORMAT_TIME,
+      GST_BUFFER_TIMESTAMP (buffer));
+
+  /* Do we need a newsegment event ? */
+  if (G_UNLIKELY (demux->video_need_segment)) {
+    if (!demux->new_seg_event) {
+      GST_DEBUG_OBJECT (demux, "pushing newsegment from %"
+          GST_TIME_FORMAT " to %" GST_TIME_FORMAT,
+          GST_TIME_ARGS (demux->segment->last_stop),
+          GST_TIME_ARGS (demux->segment->stop));
+      demux->new_seg_event =
+          gst_event_new_new_segment (FALSE, demux->segment->rate,
+          demux->segment->format, demux->segment->last_stop,
+          demux->segment->stop, demux->segment->last_stop);
+    } else {
+      GST_DEBUG_OBJECT (demux, "pushing pre-generated newsegment event");
+    }
+
+    gst_pad_push_event (demux->video_pad, gst_event_ref (demux->new_seg_event));
+
+    demux->video_need_segment = FALSE;
+  }
+
+  /* FIXME: safety checks */
+  memcpy (GST_BUFFER_DATA (buffer), data + 7 + codec_data,
+      demux->tag_data_size - codec_data);
+
+  GST_LOG_OBJECT (demux, "pushing %d bytes buffer at pts %" GST_TIME_FORMAT
+      " with duration %" GST_TIME_FORMAT ", offset %" G_GUINT64_FORMAT
+      ", keyframe (%d)", GST_BUFFER_SIZE (buffer),
+      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
+      GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)), GST_BUFFER_OFFSET (buffer),
+      keyframe);
+
+  /* Push downstream */
+  ret = gst_pad_push (demux->video_pad, buffer);
+
+beach:
+  return ret;
+}
+
+GstFlowReturn
+gst_flv_parse_tag_type (GstFLVDemux * demux, const guint8 * data,
+    size_t data_size)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+  guint8 tag_type = 0;
+
+  tag_type = data[0];
+
+  switch (tag_type) {
+    case 9:
+      demux->state = FLV_STATE_TAG_VIDEO;
+      demux->has_video = TRUE;
+      break;
+    case 8:
+      demux->state = FLV_STATE_TAG_AUDIO;
+      demux->has_audio = TRUE;
+      break;
+    case 18:
+      demux->state = FLV_STATE_TAG_SCRIPT;
+      break;
+    default:
+      GST_WARNING_OBJECT (demux, "unsupported tag type %u", tag_type);
+  }
+
+  /* Tag size is 1 byte of type + 3 bytes of size + 7 bytes + tag data size +
+   * 4 bytes of previous tag size */
+  demux->tag_data_size = FLV_GET_BEUI24 (data + 1, data_size - 1);
+  demux->tag_size = demux->tag_data_size + 11;
+
+  GST_LOG_OBJECT (demux, "tag data size is %" G_GUINT64_FORMAT,
+      demux->tag_data_size);
+
+  return ret;
+}
+
+GstFlowReturn
+gst_flv_parse_header (GstFLVDemux * demux, const guint8 * data,
+    size_t data_size)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  /* Check for the FLV tag */
+  if (data[0] == 'F' && data[1] == 'L' && data[2] == 'V') {
+    GST_DEBUG_OBJECT (demux, "FLV header detected");
+  } else {
+    if (G_UNLIKELY (demux->strict)) {
+      GST_WARNING_OBJECT (demux, "invalid header tag detected");
+      ret = GST_FLOW_UNEXPECTED;
+      goto beach;
+    }
+  }
+
+  /* Jump over the 4 first bytes */
+  data += 4;
+
+  /* Now look at audio/video flags */
+  {
+    guint8 flags = data[0];
+
+    demux->has_video = demux->has_audio = FALSE;
+
+    if (flags & 1) {
+      GST_DEBUG_OBJECT (demux, "there is a video stream");
+      demux->has_video = TRUE;
+    }
+    if (flags & 4) {
+      GST_DEBUG_OBJECT (demux, "there is an audio stream");
+      demux->has_audio = TRUE;
+    }
+  }
+
+  /* We don't care about the rest */
+  demux->need_header = FALSE;
+
+beach:
+  return ret;
+}
diff -up /dev/null gst-plugins-bad-0.10.5/gst/flv/Makefile.in
--- /dev/null	2008-02-05 09:36:22.221546318 +0100
+++ gst-plugins-bad-0.10.5/gst/flv/Makefile.in	2008-02-05 10:33:21.000000000 +0100
@@ -0,0 +1,689 @@
+# Makefile.in generated by automake 1.10 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = gst/flv
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/common/m4/as-ac-expand.m4 \
+	$(top_srcdir)/common/m4/as-auto-alt.m4 \
+	$(top_srcdir)/common/m4/as-compiler-flag.m4 \
+	$(top_srcdir)/common/m4/as-objc.m4 \
+	$(top_srcdir)/common/m4/as-python.m4 \
+	$(top_srcdir)/common/m4/as-scrub-include.m4 \
+	$(top_srcdir)/common/m4/as-version.m4 \
+	$(top_srcdir)/common/m4/ax_create_stdint_h.m4 \
+	$(top_srcdir)/common/m4/gst-arch.m4 \
+	$(top_srcdir)/common/m4/gst-args.m4 \
+	$(top_srcdir)/common/m4/gst-check.m4 \
+	$(top_srcdir)/common/m4/gst-error.m4 \
+	$(top_srcdir)/common/m4/gst-feature.m4 \
+	$(top_srcdir)/common/m4/gst-gettext.m4 \
+	$(top_srcdir)/common/m4/gst-glib2.m4 \
+	$(top_srcdir)/common/m4/gst-plugin-docs.m4 \
+	$(top_srcdir)/common/m4/gst-plugindir.m4 \
+	$(top_srcdir)/common/m4/gst.m4 \
+	$(top_srcdir)/common/m4/gtk-doc.m4 \
+	$(top_srcdir)/common/m4/pkg.m4 $(top_srcdir)/m4/gettext.m4 \
+	$(top_srcdir)/m4/gst-alsa.m4 $(top_srcdir)/m4/gst-sdl.m4 \
+	$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/lib-ld.m4 \
+	$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \
+	$(top_srcdir)/m4/progtest.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(plugindir)"
+pluginLTLIBRARIES_INSTALL = $(INSTALL)
+LTLIBRARIES = $(plugin_LTLIBRARIES)
+am__DEPENDENCIES_1 =
+libgstflvdemux_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
+am_libgstflvdemux_la_OBJECTS = libgstflvdemux_la-gstflvdemux.lo \
+	libgstflvdemux_la-gstflvparse.lo
+libgstflvdemux_la_OBJECTS = $(am_libgstflvdemux_la_OBJECTS)
+libgstflvdemux_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libgstflvdemux_la_CFLAGS) $(CFLAGS) \
+	$(libgstflvdemux_la_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I. -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libgstflvdemux_la_SOURCES)
+DIST_SOURCES = $(libgstflvdemux_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ACLOCAL_AMFLAGS = @ACLOCAL_AMFLAGS@
+ALSA_CFLAGS = @ALSA_CFLAGS@
+ALSA_LIBS = @ALSA_LIBS@
+AMRWB_LIBS = @AMRWB_LIBS@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BZ2_LIBS = @BZ2_LIBS@
+CC = @CC@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CDAUDIO_CFLAGS = @CDAUDIO_CFLAGS@
+CDAUDIO_CONFIG = @CDAUDIO_CONFIG@
+CDAUDIO_LIBS = @CDAUDIO_LIBS@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DEPRECATED_CFLAGS = @DEPRECATED_CFLAGS@
+DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
+DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DIVXDEC_LIBS = @DIVXDEC_LIBS@
+DIVXENC_LIBS = @DIVXENC_LIBS@
+DTS_LIBS = @DTS_LIBS@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+ERROR_CFLAGS = @ERROR_CFLAGS@
+EXEEXT = @EXEEXT@
+EXIF_CFLAGS = @EXIF_CFLAGS@
+EXIF_LIBS = @EXIF_LIBS@
+F77 = @F77@
+FAAC_LIBS = @FAAC_LIBS@
+FAAD_IS_NEAAC = @FAAD_IS_NEAAC@
+FAAD_LIBS = @FAAD_LIBS@
+FFLAGS = @FFLAGS@
+GCOV = @GCOV@
+GCOV_CFLAGS = @GCOV_CFLAGS@
+GCOV_LIBS = @GCOV_LIBS@
+GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
+GIO_CFLAGS = @GIO_CFLAGS@
+GIO_LIBS = @GIO_LIBS@
+GLADE_CFLAGS = @GLADE_CFLAGS@
+GLADE_LIBS = @GLADE_LIBS@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_LIBS = @GLIB_LIBS@
+GLIB_PREFIX = @GLIB_PREFIX@
+GLIB_REQ = @GLIB_REQ@
+GL_CFLAGS = @GL_CFLAGS@
+GL_LIBS = @GL_LIBS@
+GMSGFMT = @GMSGFMT@
+GMYTH_CFLAGS = @GMYTH_CFLAGS@
+GMYTH_LIBS = @GMYTH_LIBS@
+GREP = @GREP@
+GSM_LIBS = @GSM_LIBS@
+GSTPB_PLUGINS_DIR = @GSTPB_PLUGINS_DIR@
+GSTPB_PREFIX = @GSTPB_PREFIX@
+GST_ALL_LDFLAGS = @GST_ALL_LDFLAGS@
+GST_BASE_CFLAGS = @GST_BASE_CFLAGS@
+GST_BASE_LIBS = @GST_BASE_LIBS@
+GST_CFLAGS = @GST_CFLAGS@
+GST_CHECK_CFLAGS = @GST_CHECK_CFLAGS@
+GST_CHECK_LIBS = @GST_CHECK_LIBS@
+GST_CONTROLLER_CFLAGS = @GST_CONTROLLER_CFLAGS@
+GST_CONTROLLER_LIBS = @GST_CONTROLLER_LIBS@
+GST_GDP_CFLAGS = @GST_GDP_CFLAGS@
+GST_GDP_LIBS = @GST_GDP_LIBS@
+GST_LEVEL_DEFAULT = @GST_LEVEL_DEFAULT@
+GST_LIBS = @GST_LIBS@
+GST_LICENSE = @GST_LICENSE@
+GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_OPTION_CFLAGS = @GST_OPTION_CFLAGS@
+GST_PACKAGE_NAME = @GST_PACKAGE_NAME@
+GST_PACKAGE_ORIGIN = @GST_PACKAGE_ORIGIN@
+GST_PLUGINS_ALL = @GST_PLUGINS_ALL@
+GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
+GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
+GST_PLUGINS_DIR = @GST_PLUGINS_DIR@
+GST_PLUGINS_SELECTED = @GST_PLUGINS_SELECTED@
+GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
+GST_PREFIX = @GST_PREFIX@
+GST_TOOLS_DIR = @GST_TOOLS_DIR@
+GTK2_CFLAGS = @GTK2_CFLAGS@
+GTK2_LIBS = @GTK2_LIBS@
+GTK_BASE_DIR = @GTK_BASE_DIR@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_LIBS = @GTK_LIBS@
+GTK_VERSION = @GTK_VERSION@
+HAVE_AMRWB = @HAVE_AMRWB@
+HAVE_BZ2 = @HAVE_BZ2@
+HAVE_CXX = @HAVE_CXX@
+HAVE_DTS = @HAVE_DTS@
+HAVE_FAAC = @HAVE_FAAC@
+HAVE_FAAD = @HAVE_FAAD@
+HAVE_GLADE = @HAVE_GLADE@
+HAVE_GSM = @HAVE_GSM@
+HAVE_GTK = @HAVE_GTK@
+HAVE_NAS = @HAVE_NAS@
+HAVE_X = @HAVE_X@
+HAVE_X264 = @HAVE_X264@
+HTML_DIR = @HTML_DIR@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INTLLIBS = @INTLLIBS@
+IPTC_CFLAGS = @IPTC_CFLAGS@
+IPTC_LIBS = @IPTC_LIBS@
+IVORBIS_CFLAGS = @IVORBIS_CFLAGS@
+IVORBIS_LIBS = @IVORBIS_LIBS@
+JACK_CFLAGS = @JACK_CFLAGS@
+JACK_LIBS = @JACK_LIBS@
+LDFLAGS = @LDFLAGS@
+LIBDC1394_CFLAGS = @LIBDC1394_CFLAGS@
+LIBDC1394_LIBS = @LIBDC1394_LIBS@
+LIBICONV = @LIBICONV@
+LIBINTL = @LIBINTL@
+LIBM = @LIBM@
+LIBMMS_CFLAGS = @LIBMMS_CFLAGS@
+LIBMMS_LIBS = @LIBMMS_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBOIL_CFLAGS = @LIBOIL_CFLAGS@
+LIBOIL_LIBS = @LIBOIL_LIBS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LOCALEDIR = @LOCALEDIR@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+METADATA_CFLAGS = @METADATA_CFLAGS@
+METADATA_LIBS = @METADATA_LIBS@
+MKDIR_P = mkdir -p
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MPEG2ENC_CFLAGS = @MPEG2ENC_CFLAGS@
+MPEG2ENC_LIBS = @MPEG2ENC_LIBS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
+MUSEPACK_LIBS = @MUSEPACK_LIBS@
+MUSICBRAINZ_CFLAGS = @MUSICBRAINZ_CFLAGS@
+MUSICBRAINZ_LIBS = @MUSICBRAINZ_LIBS@
+NAS_CFLAGS = @NAS_CFLAGS@
+NAS_LIBS = @NAS_LIBS@
+NEON_CFLAGS = @NEON_CFLAGS@
+NEON_LIBS = @NEON_LIBS@
+OBJC = @OBJC@
+OBJCDEPMODE = @OBJCDEPMODE@
+OBJC_LDFLAGS = @OBJC_LDFLAGS@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PACKAGE_VERSION_MAJOR = @PACKAGE_VERSION_MAJOR@
+PACKAGE_VERSION_MICRO = @PACKAGE_VERSION_MICRO@
+PACKAGE_VERSION_MINOR = @PACKAGE_VERSION_MINOR@
+PACKAGE_VERSION_NANO = @PACKAGE_VERSION_NANO@
+PACKAGE_VERSION_RELEASE = @PACKAGE_VERSION_RELEASE@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PLUGINDIR = @PLUGINDIR@
+POSUB = @POSUB@
+PROFILE_CFLAGS = @PROFILE_CFLAGS@
+PYTHON = @PYTHON@
+PYTHON_EXEC_PREFIX = @PYTHON_EXEC_PREFIX@
+PYTHON_PLATFORM = @PYTHON_PLATFORM@
+PYTHON_PREFIX = @PYTHON_PREFIX@
+PYTHON_VERSION = @PYTHON_VERSION@
+RANLIB = @RANLIB@
+SDL_CFLAGS = @SDL_CFLAGS@
+SDL_CONFIG = @SDL_CONFIG@
+SDL_LIBS = @SDL_LIBS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
+SNDFILE_LIBS = @SNDFILE_LIBS@
+SOUNDTOUCH_CFLAGS = @SOUNDTOUCH_CFLAGS@
+SOUNDTOUCH_LIBS = @SOUNDTOUCH_LIBS@
+SOUP_CFLAGS = @SOUP_CFLAGS@
+SOUP_LIBS = @SOUP_LIBS@
+SPC_LIBS = @SPC_LIBS@
+STRIP = @STRIP@
+SWFDEC_CFLAGS = @SWFDEC_CFLAGS@
+SWFDEC_LIBS = @SWFDEC_LIBS@
+THEORADEC_CFLAGS = @THEORADEC_CFLAGS@
+THEORADEC_LIBS = @THEORADEC_LIBS@
+TIMIDITY_CFLAGS = @TIMIDITY_CFLAGS@
+TIMIDITY_LIBS = @TIMIDITY_LIBS@
+USE_NLS = @USE_NLS@
+VALGRIND_CFLAGS = @VALGRIND_CFLAGS@
+VALGRIND_LIBS = @VALGRIND_LIBS@
+VALGRIND_PATH = @VALGRIND_PATH@
+VERSION = @VERSION@
+WILDMIDI_CFLAGS = @WILDMIDI_CFLAGS@
+WILDMIDI_LIBS = @WILDMIDI_LIBS@
+X264_CFLAGS = @X264_CFLAGS@
+X264_LIBS = @X264_LIBS@
+XGETTEXT = @XGETTEXT@
+XMKMF = @XMKMF@
+XMP_1_99_5_CFLAGS = @XMP_1_99_5_CFLAGS@
+XMP_1_99_5_LIBS = @XMP_1_99_5_LIBS@
+XMP_CFLAGS = @XMP_CFLAGS@
+XMP_LIBS = @XMP_LIBS@
+XVID_LIBS = @XVID_LIBS@
+X_CFLAGS = @X_CFLAGS@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_LIBS = @X_LIBS@
+X_PRE_LIBS = @X_PRE_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_OBJC = @ac_ct_OBJC@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+pkgpyexecdir = @pkgpyexecdir@
+pkgpythondir = @pkgpythondir@
+plugindir = @plugindir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+pyexecdir = @pyexecdir@
+pythondir = @pythondir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+plugin_LTLIBRARIES = libgstflvdemux.la
+libgstflvdemux_la_CFLAGS = ${GST_CFLAGS}
+libgstflvdemux_la_LIBADD = $(GST_BASE_LIBS)
+libgstflvdemux_la_LDFLAGS = ${GST_PLUGIN_LDFLAGS} 
+libgstflvdemux_la_SOURCES = gstflvdemux.c gstflvparse.c
+noinst_HEADERS = gstflvdemux.h gstflvparse.h
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  gst/flv/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  gst/flv/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-pluginLTLIBRARIES: $(plugin_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(plugindir)" || $(MKDIR_P) "$(DESTDIR)$(plugindir)"
+	@list='$(plugin_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f=$(am__strip_dir) \
+	    echo " $(LIBTOOL) --mode=install $(pluginLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(plugindir)/$$f'"; \
+	    $(LIBTOOL) --mode=install $(pluginLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) "$$p" "$(DESTDIR)$(plugindir)/$$f"; \
+	  else :; fi; \
+	done
+
+uninstall-pluginLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(plugin_LTLIBRARIES)'; for p in $$list; do \
+	  p=$(am__strip_dir) \
+	  echo " $(LIBTOOL) --mode=uninstall rm -f '$(DESTDIR)$(plugindir)/$$p'"; \
+	  $(LIBTOOL) --mode=uninstall rm -f "$(DESTDIR)$(plugindir)/$$p"; \
+	done
+
+clean-pluginLTLIBRARIES:
+	-test -z "$(plugin_LTLIBRARIES)" || rm -f $(plugin_LTLIBRARIES)
+	@list='$(plugin_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libgstflvdemux.la: $(libgstflvdemux_la_OBJECTS) $(libgstflvdemux_la_DEPENDENCIES) 
+	$(libgstflvdemux_la_LINK) -rpath $(plugindir) $(libgstflvdemux_la_OBJECTS) $(libgstflvdemux_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgstflvdemux_la-gstflvdemux.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgstflvdemux_la-gstflvparse.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+libgstflvdemux_la-gstflvdemux.lo: gstflvdemux.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstflvdemux_la_CFLAGS) $(CFLAGS) -MT libgstflvdemux_la-gstflvdemux.lo -MD -MP -MF $(DEPDIR)/libgstflvdemux_la-gstflvdemux.Tpo -c -o libgstflvdemux_la-gstflvdemux.lo `test -f 'gstflvdemux.c' || echo '$(srcdir)/'`gstflvdemux.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libgstflvdemux_la-gstflvdemux.Tpo $(DEPDIR)/libgstflvdemux_la-gstflvdemux.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='gstflvdemux.c' object='libgstflvdemux_la-gstflvdemux.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstflvdemux_la_CFLAGS) $(CFLAGS) -c -o libgstflvdemux_la-gstflvdemux.lo `test -f 'gstflvdemux.c' || echo '$(srcdir)/'`gstflvdemux.c
+
+libgstflvdemux_la-gstflvparse.lo: gstflvparse.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstflvdemux_la_CFLAGS) $(CFLAGS) -MT libgstflvdemux_la-gstflvparse.lo -MD -MP -MF $(DEPDIR)/libgstflvdemux_la-gstflvparse.Tpo -c -o libgstflvdemux_la-gstflvparse.lo `test -f 'gstflvparse.c' || echo '$(srcdir)/'`gstflvparse.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libgstflvdemux_la-gstflvparse.Tpo $(DEPDIR)/libgstflvdemux_la-gstflvparse.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='gstflvparse.c' object='libgstflvdemux_la-gstflvparse.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstflvdemux_la_CFLAGS) $(CFLAGS) -c -o libgstflvdemux_la-gstflvparse.lo `test -f 'gstflvparse.c' || echo '$(srcdir)/'`gstflvparse.c
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(plugindir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-pluginLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-pluginLTLIBRARIES
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-pluginLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-pluginLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-pluginLTLIBRARIES \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-pluginLTLIBRARIES
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -up gst-plugins-bad-0.10.5/gst/Makefile.am.flv gst-plugins-bad-0.10.5/gst/Makefile.am
--- gst-plugins-bad-0.10.5/gst/Makefile.am.flv	2007-06-13 11:20:44.000000000 +0200
+++ gst-plugins-bad-0.10.5/gst/Makefile.am	2008-02-05 10:33:21.000000000 +0100
@@ -1,2 +1,2 @@
-SUBDIRS = $(GST_PLUGINS_SELECTED)
-DIST_SUBDIRS = $(GST_PLUGINS_ALL)
+SUBDIRS = $(GST_PLUGINS_SELECTED) flv
+DIST_SUBDIRS = $(GST_PLUGINS_ALL) flv
diff -up gst-plugins-bad-0.10.5/gst/Makefile.in.flv gst-plugins-bad-0.10.5/gst/Makefile.in
--- gst-plugins-bad-0.10.5/gst/Makefile.in.flv	2007-06-19 10:44:26.000000000 +0200
+++ gst-plugins-bad-0.10.5/gst/Makefile.in	2008-02-05 10:33:21.000000000 +0100
@@ -461,8 +461,8 @@ sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
-SUBDIRS = $(GST_PLUGINS_SELECTED)
-DIST_SUBDIRS = $(GST_PLUGINS_ALL)
+SUBDIRS = $(GST_PLUGINS_SELECTED) flv
+DIST_SUBDIRS = $(GST_PLUGINS_ALL) flv
 all: all-recursive
 
 .SUFFIXES:
diff -up gst-plugins-bad-0.10.5/configure.ac.flv gst-plugins-bad-0.10.5/configure.ac
--- gst-plugins-bad-0.10.5/configure.ac.flv	2008-02-05 10:34:31.000000000 +0100
+++ gst-plugins-bad-0.10.5/configure.ac	2008-02-05 10:35:50.000000000 +0100
@@ -970,6 +970,7 @@ gst/cdxaparse/Makefile
 gst/deinterlace/Makefile
 gst/equalizer/Makefile
 gst/filter/Makefile
+gst/flv/Makefile
 gst/freeze/Makefile
 gst/h264parse/Makefile
 gst/interleave/Makefile
diff -up gst-plugins-bad-0.10.5/configure.flv gst-plugins-bad-0.10.5/configure
--- gst-plugins-bad-0.10.5/configure.flv	2008-02-05 10:34:40.000000000 +0100
+++ gst-plugins-bad-0.10.5/configure	2008-02-05 10:35:48.000000000 +0100
@@ -42403,7 +42403,7 @@ GST_PLUGIN_LDFLAGS="-module -avoid-versi
 
 
 
-ac_config_files="$ac_config_files Makefile gst-plugins-bad.spec gst/Makefile gst/app/Makefile gst/bayer/Makefile gst/cdxaparse/Makefile gst/deinterlace/Makefile gst/equalizer/Makefile gst/filter/Makefile gst/freeze/Makefile gst/h264parse/Makefile gst/interleave/Makefile gst/librfb/Makefile gst/modplug/Makefile gst/modplug/libmodplug/Makefile gst/mpegvideoparse/Makefile gst/multifile/Makefile gst/mve/Makefile gst/nsf/Makefile gst/nuvdemux/Makefile gst/replaygain/Makefile gst/rtpmanager/Makefile gst/spectrum/Makefile gst/speed/Makefile gst/switch/Makefile gst/tta/Makefile gst/videoparse/Makefile gst/videosignal/Makefile gst/vmnc/Makefile gst/xingheader/Makefile gst/real/Makefile gst/y4m/Makefile gst-libs/Makefile gst-libs/gst/Makefile gst-libs/gst/app/Makefile sys/Makefile sys/glsink/Makefile sys/dvb/Makefile sys/vcd/Makefile examples/Makefile examples/app/Makefile examples/directfb/Makefile examples/switch/Makefile ext/amrwb/Makefile ext/alsaspdif/Makefile ext/bz2/Makefile ext/cdaudio/Makefile ext/directfb/Makefile ext/divx/Makefile ext/dts/Makefile ext/faac/Makefile ext/faad/Makefile ext/gsm/Makefile ext/ivorbis/Makefile ext/jack/Makefile ext/ladspa/Makefile ext/libmms/Makefile ext/Makefile ext/nas/Makefile ext/mpeg2enc/Makefile ext/musepack/Makefile ext/musicbrainz/Makefile ext/mythtv/Makefile ext/neon/Makefile ext/sdl/Makefile ext/sndfile/Makefile ext/soundtouch/Makefile ext/spc/Makefile ext/swfdec/Makefile ext/theora/Makefile ext/timidity/Makefile ext/x264/Makefile ext/xvid/Makefile po/Makefile.in docs/Makefile docs/plugins/Makefile docs/version.entities common/Makefile common/m4/Makefile m4/Makefile tests/Makefile tests/check/Makefile tests/icles/Makefile"
+ac_config_files="$ac_config_files Makefile gst-plugins-bad.spec gst/Makefile gst/app/Makefile gst/bayer/Makefile gst/cdxaparse/Makefile gst/deinterlace/Makefile gst/equalizer/Makefile gst/filter/Makefile gst/flv/Makefile gst/freeze/Makefile gst/h264parse/Makefile gst/interleave/Makefile gst/librfb/Makefile gst/modplug/Makefile gst/modplug/libmodplug/Makefile gst/mpegvideoparse/Makefile gst/multifile/Makefile gst/mve/Makefile gst/nsf/Makefile gst/nuvdemux/Makefile gst/replaygain/Makefile gst/rtpmanager/Makefile gst/spectrum/Makefile gst/speed/Makefile gst/switch/Makefile gst/tta/Makefile gst/videoparse/Makefile gst/videosignal/Makefile gst/vmnc/Makefile gst/xingheader/Makefile gst/real/Makefile gst/y4m/Makefile gst-libs/Makefile gst-libs/gst/Makefile gst-libs/gst/app/Makefile sys/Makefile sys/glsink/Makefile sys/dvb/Makefile sys/vcd/Makefile examples/Makefile examples/app/Makefile examples/directfb/Makefile examples/switch/Makefile ext/amrwb/Makefile ext/alsaspdif/Makefile ext/bz2/Makefile ext/cdaudio/Makefile ext/directfb/Makefile ext/divx/Makefile ext/dts/Makefile ext/faac/Makefile ext/faad/Makefile ext/gsm/Makefile ext/ivorbis/Makefile ext/jack/Makefile ext/ladspa/Makefile ext/libmms/Makefile ext/Makefile ext/nas/Makefile ext/mpeg2enc/Makefile ext/musepack/Makefile ext/musicbrainz/Makefile ext/mythtv/Makefile ext/neon/Makefile ext/sdl/Makefile ext/sndfile/Makefile ext/soundtouch/Makefile ext/spc/Makefile ext/swfdec/Makefile ext/theora/Makefile ext/timidity/Makefile ext/x264/Makefile ext/xvid/Makefile po/Makefile.in docs/Makefile docs/plugins/Makefile docs/version.entities common/Makefile common/m4/Makefile m4/Makefile tests/Makefile tests/check/Makefile tests/icles/Makefile"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -43712,6 +43712,7 @@ do
     "gst/deinterlace/Makefile") CONFIG_FILES="$CONFIG_FILES gst/deinterlace/Makefile" ;;
     "gst/equalizer/Makefile") CONFIG_FILES="$CONFIG_FILES gst/equalizer/Makefile" ;;
     "gst/filter/Makefile") CONFIG_FILES="$CONFIG_FILES gst/filter/Makefile" ;;
+    "gst/flv/Makefile") CONFIG_FILES="$CONFIG_FILES gst/flv/Makefile" ;;
     "gst/freeze/Makefile") CONFIG_FILES="$CONFIG_FILES gst/freeze/Makefile" ;;
     "gst/h264parse/Makefile") CONFIG_FILES="$CONFIG_FILES gst/h264parse/Makefile" ;;
     "gst/interleave/Makefile") CONFIG_FILES="$CONFIG_FILES gst/interleave/Makefile" ;;
